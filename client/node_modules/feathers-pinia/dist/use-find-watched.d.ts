import type { UseFindWatchedOptionsStandalone } from './service-store/types';
import type { Params, Paginated } from './types';
import { Ref } from 'vue-demi';
import { BaseModel } from './service-store';
export declare function useFindWatched<M extends BaseModel = BaseModel>({ model, params, fetchParams, qid, queryWhen, local, immediate, }: UseFindWatchedOptionsStandalone<M>): {
    find: (params?: Params | Ref<Params> | undefined) => void | Promise<M[] | Paginated<M>>;
    debounceTime: Ref<number | null>;
    qid: Ref<string>;
    isPending: Ref<boolean>;
    haveBeenRequested: Ref<boolean>;
    haveLoaded: Ref<boolean>;
    error: Ref<{
        name: string;
        message: string;
        stack?: string | undefined;
        cause?: any | undefined;
    } | null>;
    latestQuery: Ref<object | null>;
    isLocal: Ref<boolean>;
    request: Ref<{
        then: <TResult1 = any, TResult2 = never>(onfulfilled?: ((value: any) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>;
        catch: <TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined) => Promise<any>;
        finally: (onfinally?: (() => void) | null | undefined) => Promise<any>;
        readonly [Symbol.toStringTag]: string;
    } | null>;
    items: import("vue-demi").ComputedRef<M[]>;
    servicePath: import("vue-demi").ComputedRef<string>;
    paginationData: import("vue-demi").ComputedRef<import("./service-store").AnyData>;
    isSsr: import("vue-demi").ComputedRef<boolean>;
};
