import type { UseGetOptionsStandalone } from './service-store/types';
import type { Id } from '@feathersjs/feathers';
import type { Params } from './types';
import { BaseModel } from './service-store';
export declare function useGetWatched<M extends BaseModel = BaseModel>({ model, id, params, queryWhen, local, immediate, }: UseGetOptionsStandalone<M>): {
    get: (id: Id | null, params?: Params | undefined) => Promise<M | undefined | any>;
    item: import("vue-demi").ComputedRef<M | null>;
    servicePath: import("vue-demi").ComputedRef<string>;
    isSsr: import("vue-demi").ComputedRef<boolean>;
    isPending: import("vue-demi").Ref<boolean>;
    hasBeenRequested: import("vue-demi").Ref<boolean>;
    hasLoaded: import("vue-demi").Ref<boolean>;
    error: import("vue-demi").Ref<{
        name: string;
        message: string;
        stack?: string | undefined;
        cause?: any | undefined;
    } | null>;
    isLocal: import("vue-demi").Ref<boolean>;
    request: import("vue-demi").Ref<{
        then: <TResult1 = any, TResult2 = never>(onfulfilled?: ((value: any) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>;
        catch: <TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined) => Promise<any>;
        finally: (onfinally?: (() => void) | null | undefined) => Promise<any>;
        readonly [Symbol.toStringTag]: string;
    } | null>;
};
