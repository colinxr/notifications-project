import type { Params, Paginated, QueryInfo, DiffDefinition } from './types';
import type { MaybeRef } from './utility-types';
import type { AnyData, AnyDataOrArray, BaseModelAssociations, FindClassParams } from './service-store/types';
import { Ref } from 'vue-demi';
/**
 * Get the id from a record in this order:
 *   1. the `idField`
 *   2. id
 *   3. _id
 * @param item
 * @param idField
 */
export declare function getId(item: any, idField: string): any;
export declare function getTempId(item: any, tempIdField: string): any;
export declare function getAnyId(item: any, tempIdField: string, idField: string): any;
export declare function getQueryInfo(params?: Params, response?: Partial<Paginated<any>>): QueryInfo;
export declare function getItemsFromQueryInfo(pagination: any, queryInfo: any, keyedById: any): any[];
/**
 * Generate a new tempId and mark the record as a temp
 * @param state
 * @param item
 */
export declare function assignTempId(item: any, tempIdField: string): any;
/**
 * Cleans data to prepare it for the server.
 * @param data item or array of items
 * @returns items without private attributes like __isClone and __tempId
 */
export declare function cleanData<T = AnyDataOrArray>(data: T, tempIdField: string): T;
/**
 * Restores tempIds to the records returned from the server. The tempIds need to be
 * temporarily put back in place in order to migrate the objects from the tempsById
 * into the itemsById. A shallow copy of the object
 *
 * Note when data is an array, it doesn't matter if the server
 * returns the items in the same order. It's only important that all of the correct
 * records are moved from tempsById to itemsById
 *
 * @param data item(s) before being passed to the server
 * @param responseData items(s) returned from the server
 */
export declare function restoreTempIds(data: AnyDataOrArray, resData: AnyDataOrArray, tempIdField: string): AnyData;
/**
 * Uses fast-copy on any data provided get an independent and reference-free copy.
 * This makes it easy to work with client-side databases like feathers-memory. It makes
 * it impossible to accidentally modify stored data due to js object in-memory references.
 * @param data item or array of items
 */
export declare function useCleanData(data: any): any;
/**
 *
 * @param data item or array of items
 * @returns object with { items[], isArray } where isArray is a boolean of if the data was an array.
 */
export declare function getArray<T>(data: T | T[]): {
    items: T[];
    isArray: boolean;
};
export declare const hasOwn: (obj: AnyData, prop: string) => boolean;
export declare function getSaveParams(params?: MaybeRef<Params>): Params;
export declare function markAsClone<T>(item: T): T;
/**
 * Copies the property definitions for the model associations from src to dest.
 *
 * @param src source instance
 * @param dest destination instance
 * @param associations {BaseModelAssociations} from Model.associations
 */
export declare function copyAssociations<M>(src: M, dest: M, associations: BaseModelAssociations): void;
export declare function pickDiff(obj: any, diffDef: DiffDefinition): any;
export declare function diff(original: AnyData, clone: AnyData, diffDef: DiffDefinition): AnyData;
export declare const setOnRef: (obj: any, key: string, val: number) => void;
export declare const computedAttr: (obj: any, key: string) => import("vue-demi").WritableComputedRef<any>;
/**
 * A wrapper for findInStore that can return server-paginated data
 */
export declare const makeUseFindItems: (store: any, params: any) => import("vue-demi").ComputedRef<any>;
export declare function makeParamsWithoutPage(params: MaybeRef<FindClassParams>): any;
export declare function updateParamsExcludePage(_params: Ref<FindClassParams>, _newParams: MaybeRef<FindClassParams>): void;
