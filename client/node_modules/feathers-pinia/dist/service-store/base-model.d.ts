/// <reference types="node" />
import { AnyData, AnyDataOrArray, ModelInstanceOptions, ModelStatic, ServiceStoreDefault, BaseModelModifierOptions, BaseModelAssociations, CloneOptions } from './types';
import { Id, NullableId, Params } from '@feathersjs/feathers';
import { EventEmitter } from 'events';
export declare class BaseModel implements AnyData {
    static readonly store: ServiceStoreDefault<BaseModel>;
    static readonly models: Record<string, any>;
    static pinia: null;
    static servicePath: string;
    static idField: string;
    static modelName: string;
    static tempIdField: string;
    static associations: BaseModelAssociations;
    __isClone: boolean;
    constructor(data?: Record<string, any>, options?: ModelInstanceOptions);
    static instanceDefaults<M extends BaseModel>(this: ModelStatic<M>, data: AnyData, options?: BaseModelModifierOptions): AnyData;
    static emitter: EventEmitter;
    static addEventListener<M extends BaseModel>(this: ModelStatic<M>, eventName: string | symbol, listener: (...args: any[]) => void): ModelStatic<M>;
    static emit<M extends BaseModel>(this: ModelStatic<M>, eventName: string | symbol, ...args: any[]): boolean;
    static eventNames<M extends BaseModel>(this: ModelStatic<M>): (string | symbol)[];
    static getMaxListeners<M extends BaseModel>(this: ModelStatic<M>): number;
    static listenerCount<M extends BaseModel>(this: ModelStatic<M>, eventName: string | symbol): number;
    static listeners<M extends BaseModel>(this: ModelStatic<M>, eventName: string | symbol): Function[];
    static off<M extends BaseModel>(this: ModelStatic<M>, eventName: string | symbol, listener: (...args: any[]) => void): ModelStatic<M>;
    static on<M extends BaseModel>(this: ModelStatic<M>, eventName: string | symbol, listener: (...args: any[]) => void): ModelStatic<M>;
    static once<M extends BaseModel>(this: ModelStatic<M>, eventName: string | symbol, listener: (...args: any[]) => void): ModelStatic<M>;
    static prependListener<M extends BaseModel>(this: ModelStatic<M>, eventName: string | symbol, listener: (...args: any[]) => void): ModelStatic<M>;
    static prependOnceListener<M extends BaseModel>(this: ModelStatic<M>, eventName: string | symbol, listener: (...args: any[]) => void): ModelStatic<M>;
    static rawListeners<M extends BaseModel>(this: ModelStatic<M>, eventName: string | symbol): Function[];
    static removeAllListeners<M extends BaseModel>(this: ModelStatic<M>, eventName?: string | symbol): ModelStatic<M>;
    static removeListener<M extends BaseModel>(this: ModelStatic<M>, eventName: string | symbol, listener: (...args: any[]) => void): ModelStatic<M>;
    static setMaxListeners<M extends BaseModel>(this: ModelStatic<M>, n: number): ModelStatic<M>;
    static find<M extends BaseModel>(this: ModelStatic<M>, params?: Params): Promise<import("..").Paginated<BaseModel>>;
    static findInStore<M extends BaseModel>(this: ModelStatic<M>, params: Params): import("..").Paginated<BaseModel>;
    static get<M extends BaseModel>(this: ModelStatic<M>, id: Id, params?: Params): Promise<BaseModel | undefined>;
    static getFromStore<M extends BaseModel>(this: ModelStatic<M>, id: Id | null, params?: Params): BaseModel | undefined;
    static count<M extends BaseModel>(this: ModelStatic<M>, params?: Params): number;
    static countInStore<M extends BaseModel>(this: ModelStatic<M>, params: Params): number;
    static addToStore<M extends BaseModel>(this: ModelStatic<M>, data: AnyDataOrArray): BaseModel;
    static update<M extends BaseModel>(this: ModelStatic<M>, id: Id, data: AnyData, params?: Params): Promise<BaseModel>;
    static patch<M extends BaseModel>(this: ModelStatic<M>, id: NullableId, data: AnyData, params?: Params): Promise<BaseModel>;
    static remove<M extends BaseModel>(this: ModelStatic<M>, id: NullableId, params?: Params): any;
    static removeFromStore<M extends BaseModel>(this: ModelStatic<M>, data: AnyDataOrArray): AnyDataOrArray;
    get Model(): ModelStatic<BaseModel>;
    /**
     * Call `this.init` in a Class's constructor to run `instanceDefaults` and `setupInstance` properly.
     * This allows default values to be specified directly in the Class's interface.
     * @param data
     */
    init(data: Record<string, any>): void;
    getId(): any;
    getTempId(): any;
    getAnyId(): any;
    get __isTemp(): boolean;
    get isSavePending(): boolean;
    get isCreatePending(): boolean;
    get isPatchPending(): boolean;
    get isUpdatePending(): boolean;
    get isRemovePending(): boolean;
    get isPending(): boolean;
    /**
     * Add the current record to the store
     */
    addToStore(): BaseModel;
    /**
     * clone the current record using the `clone` action
     */
    clone(data?: AnyData, options?: CloneOptions): this;
    /**
     * Update a store instance to match a clone.
     */
    commit(data?: any): this;
    /**
     * Update a clone to match a store instance.
     */
    reset(data?: AnyData): this;
    /**
     * A shortcut to either call create or patch/update
     * @param params
     */
    save(params?: any): Promise<this>;
    /**
     * Calls service create with the current instance data
     * @param params
     */
    create(params?: any): Promise<this>;
    /**
     * Calls service patch with the current instance data
     * @param params
     */
    patch<M extends BaseModel>(this: M, params?: any): Promise<this>;
    /**
     * Calls service update with the current instance data
     * @param params
     */
    update(params?: any): Promise<this>;
    /**
     * Calls service remove with the current instance id
     * @param params
     */
    remove(params?: Params): Promise<this>;
    /**
     * Removes the instance from the store
     */
    removeFromStore(): this;
}
