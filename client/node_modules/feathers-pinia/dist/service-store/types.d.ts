import type { Params, Paginated, QueryInfo, HandleEvents } from '../types';
import type { Ref, ComputedRef } from 'vue-demi';
import type { Id, Query, NullableId, Application as FeathersClient } from '@feathersjs/feathers';
import type { StateTree, Store as _Store, StoreDefinition, _GettersTree, DefineStoreOptionsBase } from 'pinia';
import type { MaybeArray, MaybeRef, TypedActions, TypedGetters } from '../utility-types';
import { BaseModel } from './base-model';
import { Find } from '../use-find';
import { Get } from '../use-get';
export declare type RequestTypeById = 'create' | 'patch' | 'update' | 'remove';
export declare type RequestTypeModel = 'find' | 'count' | 'get';
declare type PendingById = {
    [key in RequestTypeById]: boolean;
};
declare type PendingByModel = {
    [key in RequestTypeModel]: boolean;
};
export declare type RequestType = RequestTypeModel & RequestTypeById;
export declare type AnyData = Record<string, any>;
export declare type AnyDataOrArray = MaybeArray<AnyData>;
declare type ModelsById<M> = {
    [id: string | number]: M;
};
interface QueryPagination {
    $limit: number;
    $skip: number;
}
interface MostRecentQuery {
    pageId: string;
    pageParams: QueryPagination;
    queriedAt: number;
    query: Query;
    queryId: string;
    queryParams: Query;
    total: number;
}
export interface CurrentQuery<M extends BaseModel> extends MostRecentQuery {
    qid: string;
    ids: number[];
    items: M[];
    total: number;
    queriedAt: number;
    queryState: PaginationStateQuery;
}
/**
 * Pagination State Types: below are types for the basic format shown here.
 * I'm surprised that something like the below can't work in TypeScript. Instead,
 * it has to be spread across the jumbled mess of interfaces and types shown below.
 * If somebody has knowledge of a cleaner representation, I'd appreciate a PR. - Marshall
 *
 * interface PaginationState {
 *   [queryId: string]: {
 *     [pageId: string]: {
 *       ids: Id[]
 *       pageParams: QueryPagination
 *       queriedAt: number
 *       ssr: boolean
 *     }
 *     queryParams: Query
 *     total: number
 *   }
 *   mostRecent: MostRecentQuery
 * }
 */
export interface PaginationPageData {
    ids: Id[];
    pageParams: QueryPagination;
    queriedAt: number;
    ssr: boolean;
}
export declare type PaginationStatePage = {
    [pageId: string]: PaginationPageData;
};
export declare type PaginationStateQuery = PaginationStatePage | {
    queryParams: Query;
    total: number;
};
export declare type PaginationStateQid = PaginationStateQuery | {
    mostRecent: MostRecentQuery;
};
export declare type ServiceStoreSharedStateDefineOptions = {
    clientAlias: string;
    servicePath: string;
    idField: string;
    tempIdField: string;
    whitelist: string[];
    paramsForServer: string[];
    skipRequestIfExists: boolean;
};
export declare type ServiceStoreDefault<M extends BaseModel> = _Store<string, ServiceStoreDefaultState<M>, ServiceStoreDefaultGetters<M>, ServiceStoreDefaultActions<M>>;
export declare type ServiceStoreDefaultState<M extends BaseModel = BaseModel> = ServiceStoreSharedStateDefineOptions & {
    pagination: {
        [qid: string]: PaginationStateQid;
    };
    itemsById: ModelsById<M>;
    tempsById: ModelsById<M>;
    clonesById: ModelsById<M>;
    pendingById: {
        Model: PendingByModel;
        [id: string]: PendingById | PendingByModel;
        [id: number]: PendingById;
    };
    eventLocksById: {
        created: ModelsById<M>;
        patched: ModelsById<M>;
        updated: ModelsById<M>;
        removed: ModelsById<M>;
    };
};
export interface ServiceStoreDefaultGetters<M extends BaseModel = BaseModel> {
    service: () => any;
    Model: () => ModelStatic<M>;
    isSsr: () => boolean;
    itemIds: () => Id[];
    items: () => M[];
    tempIds: () => string[];
    temps: () => M[];
    cloneIds: () => Id[];
    clones: () => M[];
    findInStore: () => (params: Params) => Paginated<M>;
    countInStore: () => (params: Params) => number;
    getFromStore: () => (id: Id | null, params?: Params) => M | undefined;
    isCreatePending: () => boolean;
    isPatchPending: () => boolean;
    isUpdatePending: () => boolean;
    isRemovePending: () => boolean;
}
export declare type HandleFindResponseOptions = {
    params: Params;
    response: any;
};
export declare type HandleFindErrorOptions = {
    params: Params;
    error: any;
};
export declare type FindFn<M extends BaseModel> = (params?: MaybeRef<Params>) => Promise<Paginated<M>>;
export declare type GetFn<M extends BaseModel> = (id?: Id, params?: MaybeRef<Params>) => Promise<M | undefined>;
export declare type GetFnWithId<M extends BaseModel> = (id: Id, params?: MaybeRef<Params>) => Promise<M | undefined>;
export declare type UseGetFn<M extends BaseModel> = (_id: MaybeRef<Id | null>, _params?: MaybeRef<GetClassParams>) => Get<M>;
export interface ServiceStoreDefaultActions<M extends BaseModel = BaseModel> {
    find: FindFn<M>;
    handleFindResponse: (findResponse: HandleFindResponseOptions) => Promise<any>;
    afterFind: <T = M[] | Paginated<M>>(response: T) => Promise<T>;
    handleFindError({ params, error }: HandleFindErrorOptions): Promise<any>;
    count: (params?: MaybeRef<Params>) => number;
    get: GetFnWithId<M>;
    create(data: AnyData, params?: MaybeRef<Params>): Promise<M>;
    create(data: AnyData[], params?: MaybeRef<Params>): Promise<M[]>;
    update: (id: Id, data: AnyData, params?: MaybeRef<Params>) => Promise<M>;
    patch: (id: NullableId, data: AnyData, params?: MaybeRef<Params>) => Promise<M>;
    remove: (id: NullableId, params?: Params) => any;
    removeFromStore<T extends AnyData>(data: T): T;
    removeFromStore<T extends AnyData[]>(data: T[]): T[];
    addToStore(data: AnyData): M;
    addToStore(data: AnyData[]): M[];
    addOrUpdate(data: AnyData): M;
    addOrUpdate(data: AnyData[]): M[];
    moveTempToItems(data: AnyData): M;
    clearAll: () => void;
    clone: (item: M, data: AnyData, options?: CloneOptions) => M;
    commit: (item: M) => M | undefined;
    reset: (item: M, data: AnyData) => M | undefined;
    updatePaginationForQuery: (options: UpdatePaginationForQueryOptions) => void;
    setPendingById(id: 'Model', method: RequestTypeModel, val: boolean): void;
    setPendingById(id: NullableId, method: RequestTypeById, val: boolean): void;
    hydrateAll: () => void;
    toggleEventLock: (idOrIds: MaybeArray<Id>, event: string) => void;
    unflagSsr: (params: Params) => void;
    useFind: (params: MaybeRef<FindClassParams>) => Find<M>;
    useFindWatched: (options: UseFindWatchedOptions) => UseFindComputed<M>;
    useGet: UseGetFn<M>;
    useGetOnce: UseGetFn<M>;
    useGetWatched: (options: UseGetOptions) => UseGetComputed<M>;
}
export declare type ServiceOptions<Id extends string = any, M extends BaseModel = BaseModel, S extends StateTree = {}, G extends _GettersTree<S> = {}, A = {}> = Required<Pick<DefineFeathersStoreOptions<Id, M, S, G, A>, 'ssr' | 'clients' | 'id' | 'clientAlias' | 'idField' | 'tempIdField' | 'servicePath' | 'Model' | 'state' | 'getters' | 'actions' | 'whitelist' | 'paramsForServer' | 'skipRequestIfExists'>>;
export declare type MakeStateOptions<M extends BaseModel = BaseModel, S extends StateTree = {}> = Pick<ServiceOptions<any, M, S>, 'servicePath' | 'clientAlias' | 'idField' | 'tempIdField' | 'state' | 'whitelist' | 'paramsForServer' | 'skipRequestIfExists'>;
export declare type MakeServiceGettersOptions<M extends BaseModel = BaseModel, S extends StateTree = {}, G extends _GettersTree<S> = {}> = Pick<ServiceOptions<any, M, S, G>, 'Model' | 'getters' | 'clients' | 'ssr'>;
export declare type MakeServiceActionsOptions<M extends BaseModel = BaseModel, S extends StateTree = {}, G extends _GettersTree<S> = {}, A = {}> = Pick<ServiceOptions<any, M, S, G, A>, 'Model' | 'getters' | 'clients' | 'ssr' | 'actions'>;
export interface Association {
    name: string;
    Model: ModelStatic<BaseModel>;
    type: 'find' | 'get';
}
export declare type BaseModelAssociations = Record<string, Association>;
/** Model instance interface */
declare type NonConstructorKeys<T> = {
    [P in keyof T]: T[P] extends new () => any ? never : P;
}[keyof T];
declare type NonConstructor<T> = Pick<T, NonConstructorKeys<T>>;
export declare type ModelStatic<M extends BaseModel = BaseModel> = NonConstructor<typeof BaseModel> & {
    new (...args: any[]): M;
};
/** Static Model interface */
export interface UpdatePaginationForQueryOptions {
    qid: string;
    response: any;
    query: any;
    preserveSsr: boolean;
}
export interface ModelInstanceOptions {
    /**
     * is creating clone
     */
    clone?: boolean;
}
export interface BaseModelModifierOptions {
    models: Record<string, any>;
    store: any;
}
export interface CloneOptions {
    useExisting?: boolean;
}
export interface UseCloneOptions {
    useExisting?: boolean;
    deep?: boolean;
}
export interface QueryWhenContext {
    items: ComputedRef<AnyData[]>;
    queryInfo: QueryInfo;
    /**
     * Pagination data for the current qid
     */
    qidData: PaginationStateQid;
    queryData: PaginationStateQuery;
    pageData: PaginationStatePage;
    isPending: ComputedRef<Boolean>;
    haveBeenRequested: ComputedRef<Boolean>;
    haveLoaded: ComputedRef<Boolean>;
    error: any;
}
export declare type QueryWhenFunction = ComputedRef<(context: QueryWhenContext) => boolean>;
export declare type ServiceStore<Id extends string = string, M extends BaseModel = BaseModel, S extends StateTree = {}, G extends _GettersTree<S> = {}, A = {}> = _Store<Id, ServiceStoreDefaultState<M> & S, ServiceStoreDefaultGetters<M> & G, ServiceStoreDefaultActions<M> & A>;
export declare type ServiceStoreDefinition<Id extends string, M extends BaseModel, S extends StateTree = {}, G extends _GettersTree<S> = {}, A = {}> = StoreDefinition<Id, ServiceStoreDefaultState<M> & S, ServiceStoreDefaultGetters<M> & G, ServiceStoreDefaultActions<M> & A>;
export interface DefineFeathersStoreOptions<Id extends string, M extends BaseModel, S extends StateTree, G, A> extends DefineStoreOptionsBase<S, _Store<Id, S, G, A>> {
    clientAlias?: string;
    idField?: string;
    tempIdField?: string;
    whitelist?: string[];
    paramsForServer?: string[];
    skipRequestIfExists?: boolean;
    ssr?: boolean;
    servicePath: string;
    Model?: ModelStatic<M>;
    clients?: {
        [alias: string]: FeathersClient;
    };
    enableEvents?: boolean;
    handleEvents?: HandleEvents<M>;
    debounceEventsTime?: number;
    debounceEventsGuarantee?: boolean;
    id?: Id;
    state?: () => S;
    getters?: TypedGetters<S, G, ServiceStoreDefaultState>;
    actions?: TypedActions<S, G, A, ServiceStoreDefaultState, ServiceStoreDefaultGetters, ServiceStoreDefaultActions>;
}
export interface GetClassParams extends Params {
    query?: Query;
    onServer?: boolean;
    immediate?: boolean;
}
export interface GetClassParamsStandalone<M extends BaseModel> extends GetClassParams {
    store: ServiceStoreDefault<M>;
}
export interface FindClassParams extends Params {
    query: Query;
    onServer?: boolean;
    qid?: string;
    immediate?: boolean;
    watch?: boolean;
}
export interface FindClassParamsStandalone<M extends BaseModel> extends FindClassParams {
    store: ServiceStoreDefault<M>;
}
export interface UseFindWatchedOptions {
    params: Params | ComputedRef<Params | null>;
    fetchParams?: ComputedRef<Params | null | undefined>;
    queryWhen?: ComputedRef<boolean> | QueryWhenFunction;
    qid?: string;
    local?: boolean;
    immediate?: boolean;
}
export interface UseFindWatchedOptionsStandalone<M extends BaseModel> extends UseFindWatchedOptions {
    model: ModelStatic<M>;
}
export interface UseFindState {
    debounceTime: null | number;
    qid: string;
    isPending: boolean;
    haveBeenRequested: boolean;
    haveLoaded: boolean;
    error: null | Error;
    latestQuery: null | object;
    isLocal: boolean;
    request: Promise<any> | null;
}
export interface UseFindComputed<M> {
    items: ComputedRef<M[]>;
    servicePath: ComputedRef<string>;
    paginationData: ComputedRef<AnyData>;
    isSsr: ComputedRef<boolean>;
}
export interface UseGetOptions {
    id: Ref<Id | null> | ComputedRef<Id | null> | null;
    params?: Ref<Params>;
    queryWhen?: Ref<boolean>;
    local?: boolean;
    immediate?: boolean;
}
export interface UseGetOptionsStandalone<M extends BaseModel> extends UseGetOptions {
    model: ModelStatic<M>;
}
export interface UseGetState {
    isPending: boolean;
    hasBeenRequested: boolean;
    hasLoaded: boolean;
    error: null | Error;
    isLocal: boolean;
    request: Promise<any> | null;
}
export interface UseGetComputed<M> {
    item: ComputedRef<M | null>;
    servicePath: ComputedRef<string>;
    isSsr: ComputedRef<boolean>;
}
export interface AssociateFindUtils<M extends BaseModel> extends Find<M> {
    useFind: (params: MaybeRef<FindClassParams>) => Find<M>;
}
export {};
