var Et = Object.defineProperty;
var kt = (n, e, t) => e in n ? Et(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var h = (n, e, t) => (kt(n, typeof e != "symbol" ? e + "" : e, t), t);
import { _ as k } from "@feathersjs/commons";
import { computed as p, unref as b, isReadonly as de, isRef as Pe, ref as j, watch as Y, reactive as ve, toRefs as me, set as F, watchEffect as jt } from "vue-demi";
import { defineStore as Xe } from "pinia";
import { filterQuery as Ft, sorter as Lt, select as Ne } from "@feathersjs/adapter-commons";
import { FetchClient as qt } from "@feathersjs/rest-client";
import { ref as z, computed as we } from "vue";
import { BadRequest as _t } from "@feathersjs/errors";
function Bt(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var Re = function(n, e) {
  e || (e = {}), typeof e == "function" && (e = { cmp: e });
  var t = typeof e.cycles == "boolean" ? e.cycles : !1, r = e.cmp && function(o) {
    return function(s) {
      return function(a, u) {
        var c = { key: a, value: s[a] }, l = { key: u, value: s[u] };
        return o(c, l);
      };
    };
  }(e.cmp), i = [];
  return function o(s) {
    if (s && s.toJSON && typeof s.toJSON == "function" && (s = s.toJSON()), s !== void 0) {
      if (typeof s == "number")
        return isFinite(s) ? "" + s : "null";
      if (typeof s != "object")
        return JSON.stringify(s);
      var a, u;
      if (Array.isArray(s)) {
        for (u = "[", a = 0; a < s.length; a++)
          a && (u += ","), u += o(s[a]) || "null";
        return u + "]";
      }
      if (s === null)
        return "null";
      if (i.indexOf(s) !== -1) {
        if (t)
          return JSON.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      }
      var c = i.push(s) - 1, l = Object.keys(s).sort(r && r(s));
      for (u = "", a = 0; a < l.length; a++) {
        var f = l[a], d = o(s[f]);
        !d || (u && (u += ","), u += JSON.stringify(f) + ":" + d);
      }
      return i.splice(c, 1), "{" + u + "}";
    }
  }(n);
}, Ze = { exports: {} }, et = { exports: {} };
/*!
 * isomorphic-mongo-objectid - v@version@
 * Pure JavaScript implementation of mongodb ObjectId for the browser and server
 * https://github.com/john-doherty/isomorphic-mongo-objectid
 * @author John Doherty <www.johndoherty.info>
 * @license MIT
 */
(function(n) {
  (function() {
    var e = 0, t = Math.floor(Math.random() * 32767), r = Math.floor(Math.random() * 16777216);
    if (typeof window < "u") {
      var i = window.localStorage, o = parseInt(i.mongoMachineId, 10);
      o >= 0 && o <= 16777215 && (r = Math.floor(i.mongoMachineId)), i.mongoMachineId = r;
    }
    function s() {
      var a = arguments;
      if (!(this instanceof s))
        return a.length > 0 ? new s(a[0], a[1], a[2], a[3]) : new s();
      typeof a[0] == "object" ? (this.timestamp = a[0].timestamp, this.machine = a[0].machine, this.pid = a[0].pid, this.increment = a[0].increment) : typeof a[0] == "string" && a[0].length === 24 ? (this.timestamp = Number("0x" + a[0].substr(0, 8)), this.machine = Number("0x" + a[0].substr(8, 6)), this.pid = Number("0x" + a[0].substr(14, 4)), this.increment = Number("0x" + a[0].substr(18, 6))) : a.length === 4 && a[0] !== null ? (this.timestamp = a[0], this.machine = a[1], this.pid = a[2], this.increment = a[3]) : (this.timestamp = Math.floor(new Date().valueOf() / 1e3), this.machine = r, this.pid = t, this.increment = e++, e > 16777215 && (e = 0));
    }
    s.prototype.getDate = function() {
      return new Date(this.timestamp * 1e3);
    }, s.prototype.toArray = function() {
      var a = this.toString(), u = [], c;
      for (c = 0; c < 12; c++)
        u[c] = parseInt(a.slice(c * 2, c * 2 + 2), 16);
      return u;
    }, s.prototype.toString = function() {
      var a = this.timestamp.toString(16), u = this.machine.toString(16), c = this.pid.toString(16), l = this.increment.toString(16);
      return [
        "00000000".substr(0, 8 - a.length) + a,
        "000000".substr(0, 6 - u.length) + u,
        "0000".substr(0, 4 - c.length) + c,
        "000000".substr(0, 6 - l.length) + l
      ].join("");
    }, n.exports = s;
  })();
})(et);
(function(n) {
  n.exports = et.exports;
})(Ze);
const At = /* @__PURE__ */ Bt(Ze.exports);
var xt = Function.prototype.toString, Se = Object.create, Mt = Object.defineProperty, Ct = Object.getOwnPropertyDescriptor, Ue = Object.getOwnPropertyNames, Be = Object.getOwnPropertySymbols, Tt = Object.getPrototypeOf, tt = Object.prototype, Nt = tt.hasOwnProperty, Rt = tt.propertyIsEnumerable, nt = typeof Be == "function", Ut = typeof WeakMap == "function", Wt = function() {
  if (Ut)
    return function() {
      return /* @__PURE__ */ new WeakMap();
    };
  var n = function() {
    function e() {
      this._keys = [], this._values = [];
    }
    return e.prototype.has = function(t) {
      return !!~this._keys.indexOf(t);
    }, e.prototype.get = function(t) {
      return this._values[this._keys.indexOf(t)];
    }, e.prototype.set = function(t, r) {
      this._keys.push(t), this._values.push(r);
    }, e;
  }();
  return function() {
    return new n();
  };
}(), rt = function(n, e) {
  var t = n.__proto__ || Tt(n);
  if (!t)
    return Se(null);
  var r = t.constructor;
  if (r === e.Object)
    return t === e.Object.prototype ? {} : Se(t);
  if (~xt.call(r).indexOf("[native code]"))
    try {
      return new r();
    } catch {
    }
  return Se(t);
}, Dt = function(n, e, t, r) {
  var i = rt(n, e);
  r.set(n, i);
  for (var o in n)
    Nt.call(n, o) && (i[o] = t(n[o], r));
  if (nt)
    for (var s = Be(n), a = 0, u = s.length, c = void 0; a < u; ++a)
      c = s[a], Rt.call(n, c) && (i[c] = t(n[c], r));
  return i;
}, We = function(n, e, t, r) {
  var i = rt(n, e);
  r.set(n, i);
  for (var o = nt ? Ue(n).concat(Be(n)) : Ue(n), s = 0, a = o.length, u = void 0, c = void 0; s < a; ++s)
    if (u = o[s], u !== "callee" && u !== "caller")
      if (c = Ct(n, u), c) {
        !c.get && !c.set && (c.value = t(n[u], r));
        try {
          Mt(i, u, c);
        } catch {
          i[u] = c.value;
        }
      } else
        i[u] = t(n[u], r);
  return i;
}, Gt = function(n) {
  var e = "";
  return n.global && (e += "g"), n.ignoreCase && (e += "i"), n.multiline && (e += "m"), n.unicode && (e += "u"), n.sticky && (e += "y"), e;
}, Qt = Array.isArray, Jt = Object.getPrototypeOf, Kt = function() {
  return typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : (console && console.error && console.error('Unable to locate global object, returning "this".'), this);
}();
function Q(n, e) {
  var t = !!(e && e.isStrict), r = e && e.realm || Kt, i = t ? We : Dt, o = function(s, a) {
    if (!s || typeof s != "object")
      return s;
    if (a.has(s))
      return a.get(s);
    var u = s.__proto__ || Jt(s), c = u && u.constructor;
    if (!c || c === r.Object)
      return i(s, r, o, a);
    var l;
    if (Qt(s)) {
      if (t)
        return We(s, r, o, a);
      l = new c(), a.set(s, l);
      for (var f = 0, d = s.length; f < d; ++f)
        l[f] = o(s[f], a);
      return l;
    }
    if (s instanceof r.Date)
      return new c(s.getTime());
    if (s instanceof r.RegExp)
      return l = new c(s.source, s.flags || Gt(s)), l.lastIndex = s.lastIndex, l;
    if (r.Map && s instanceof r.Map)
      return l = new c(), a.set(s, l), s.forEach(function(v, I) {
        l.set(I, o(v, a));
      }), l;
    if (r.Set && s instanceof r.Set)
      return l = new c(), a.set(s, l), s.forEach(function(v) {
        l.add(o(v, a));
      }), l;
    if (r.Blob && s instanceof r.Blob)
      return s.slice(0, s.size, s.type);
    if (r.Buffer && r.Buffer.isBuffer(s))
      return l = r.Buffer.allocUnsafe ? r.Buffer.allocUnsafe(s.length) : new c(s.length), a.set(s, l), s.copy(l), l;
    if (r.ArrayBuffer) {
      if (r.ArrayBuffer.isView(s))
        return l = new c(s.buffer.slice(0)), a.set(s, l), l;
      if (s instanceof r.ArrayBuffer)
        return l = s.slice(0), a.set(s, l), l;
    }
    return typeof s.then == "function" || s instanceof Error || r.WeakMap && s instanceof r.WeakMap || r.WeakSet && s instanceof r.WeakSet ? s : i(s, r, o, a);
  };
  return o(n, Wt());
}
Q.default = Q;
Q.strict = function(e, t) {
  return Q(e, {
    isStrict: !0,
    realm: t ? t.realm : void 0
  });
};
var $e = function n(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    var r, i, o;
    if (Array.isArray(e)) {
      if (r = e.length, r != t.length)
        return !1;
      for (i = r; i-- !== 0; )
        if (!n(e[i], t[i]))
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    if (o = Object.keys(e), r = o.length, r !== Object.keys(t).length)
      return !1;
    for (i = r; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, o[i]))
        return !1;
    for (i = r; i-- !== 0; ) {
      var s = o[i];
      if (!n(e[s], t[s]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
};
function ce(n) {
  return typeof n == "object" && n != null ? n.toString() : n;
}
function $(n, e) {
  if (!!n) {
    if (e && n[e] != null)
      return ce(n[e]);
    if (n.id != null)
      return ce(n.id);
    if (n._id != null)
      return ce(n._id);
  }
}
function K(n, e) {
  if ((n == null ? void 0 : n[e]) != null)
    return ce(n[e]);
}
function ae(n, e, t) {
  return $(n, t) != null ? $(n, t) : K(n, e);
}
function V(n = {}, e = {}) {
  const { query: t = {}, qid: r = "default" } = n, i = e.limit != null ? e.limit : t == null ? void 0 : t.$limit, o = e.skip != null ? e.skip : t == null ? void 0 : t.$skip, s = i !== void 0 ? { $limit: i, $skip: o } : void 0, a = s ? Re(s) : void 0, u = k.omit(t, "$limit", "$skip"), c = Re(u);
  return {
    qid: r,
    query: t,
    queryId: c,
    queryParams: u,
    pageParams: s,
    pageId: a,
    response: e,
    isOutdated: void 0
  };
}
function Vt(n, e, t) {
  const { queryId: r, pageId: i } = e, o = n[r], s = o && o[i], a = s && s.ids;
  return a && a.length ? Object.values(k.pick(t, ...a)) : [];
}
function Yt(n, e) {
  const t = new At().toString();
  return n[e] = t, n;
}
function be(n, e) {
  const { items: t, isArray: r } = re(n), i = t.map((o) => k.omit(o, e));
  return r ? i : i[0];
}
function Ht(n, e, t) {
  const { items: r, isArray: i } = re(n), { items: o } = re(e);
  return o.forEach((s, a) => {
    const u = r[a][t];
    u && (s[t] = u);
  }), i ? o : o[0];
}
function re(n) {
  const e = Array.isArray(n);
  return { items: e ? n : [n], isArray: e };
}
const D = (n, e) => Object.prototype.hasOwnProperty.call(n, e);
function H(n) {
  return n ? Q(b(n)) : {};
}
function De(n) {
  return Object.defineProperty(n, "__isClone", {
    value: !0,
    enumerable: !1
  }), n;
}
function Ge(n, e, t) {
  Object.keys(t).forEach((r) => {
    const i = Object.getOwnPropertyDescriptor(n, r);
    Object.defineProperty(e, r, i);
  });
}
function Ee(n, e) {
  if (!e)
    return n;
  const r = (typeof e == "string" ? [e] : Array.isArray(e) ? e : Object.keys(e || n)).map((i) => i.toString().split(".")[0]);
  return k.pick(n, ...r);
}
function zt(n, e, t) {
  const r = Ee(n, t), i = Ee(e, t);
  return typeof t != "string" && !Array.isArray(t) && Object.assign(i, t), $e(r, i) ? {} : Object.keys(i).reduce((a, u) => ($e(n[u], i[u]) || (a[u] = i[u]), a), {});
}
const Xt = (n, e, t) => {
  (n.value || n)[e] = t;
}, Z = (n, e) => p({
  set: (t) => Xt(n, e, t),
  get: () => b(n)[e]
}), ke = (n, e) => p(() => {
  const t = b(e);
  if (t)
    if (t.paginate || t.onServer) {
      const { defaultSkip: r, defaultLimit: i } = n.pagination, o = t.query.$skip || r, s = t.query.$limit || i, a = n.pagination[t.qid || "default"] || {}, u = o != null && s != null ? { limit: s, skip: o } : {}, c = V(t, u);
      return Vt(a, c, n.itemsById);
    } else
      return n.findInStore(t).data;
  else
    return [];
});
function Zt(n) {
  n = b(n);
  const e = k.omit(n.query, "$limit", "$skip");
  return { ...k.omit(n, "query", "store"), query: e };
}
function en(n, e) {
  e = b(e);
  const t = k.omit(e.query, "$limit", "$skip"), r = k.omit(n.value, "store", "query");
  Object.assign(n.value.query, t), Object.assign(n.value, r);
}
const te = {};
function tn(n, e) {
  te[e.clientAlias] = te[e.clientAlias] || {}, te[e.clientAlias][n.modelName] = n;
}
var Ae = { exports: {} }, ne = typeof Reflect == "object" ? Reflect : null, Qe = ne && typeof ne.apply == "function" ? ne.apply : function(e, t, r) {
  return Function.prototype.apply.call(e, t, r);
}, le;
ne && typeof ne.ownKeys == "function" ? le = ne.ownKeys : Object.getOwnPropertySymbols ? le = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : le = function(e) {
  return Object.getOwnPropertyNames(e);
};
function nn(n) {
  console && console.warn && console.warn(n);
}
var it = Number.isNaN || function(e) {
  return e !== e;
};
function w() {
  w.init.call(this);
}
Ae.exports = w;
Ae.exports.once = an;
w.EventEmitter = w;
w.prototype._events = void 0;
w.prototype._eventsCount = 0;
w.prototype._maxListeners = void 0;
var Je = 10;
function ye(n) {
  if (typeof n != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof n);
}
Object.defineProperty(w, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return Je;
  },
  set: function(n) {
    if (typeof n != "number" || n < 0 || it(n))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + n + ".");
    Je = n;
  }
});
w.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
w.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || it(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function st(n) {
  return n._maxListeners === void 0 ? w.defaultMaxListeners : n._maxListeners;
}
w.prototype.getMaxListeners = function() {
  return st(this);
};
w.prototype.emit = function(e) {
  for (var t = [], r = 1; r < arguments.length; r++)
    t.push(arguments[r]);
  var i = e === "error", o = this._events;
  if (o !== void 0)
    i = i && o.error === void 0;
  else if (!i)
    return !1;
  if (i) {
    var s;
    if (t.length > 0 && (s = t[0]), s instanceof Error)
      throw s;
    var a = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
    throw a.context = s, a;
  }
  var u = o[e];
  if (u === void 0)
    return !1;
  if (typeof u == "function")
    Qe(u, this, t);
  else
    for (var c = u.length, l = lt(u, c), r = 0; r < c; ++r)
      Qe(l[r], this, t);
  return !0;
};
function ot(n, e, t, r) {
  var i, o, s;
  if (ye(t), o = n._events, o === void 0 ? (o = n._events = /* @__PURE__ */ Object.create(null), n._eventsCount = 0) : (o.newListener !== void 0 && (n.emit(
    "newListener",
    e,
    t.listener ? t.listener : t
  ), o = n._events), s = o[e]), s === void 0)
    s = o[e] = t, ++n._eventsCount;
  else if (typeof s == "function" ? s = o[e] = r ? [t, s] : [s, t] : r ? s.unshift(t) : s.push(t), i = st(n), i > 0 && s.length > i && !s.warned) {
    s.warned = !0;
    var a = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a.name = "MaxListenersExceededWarning", a.emitter = n, a.type = e, a.count = s.length, nn(a);
  }
  return n;
}
w.prototype.addListener = function(e, t) {
  return ot(this, e, t, !1);
};
w.prototype.on = w.prototype.addListener;
w.prototype.prependListener = function(e, t) {
  return ot(this, e, t, !0);
};
function rn() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function at(n, e, t) {
  var r = { fired: !1, wrapFn: void 0, target: n, type: e, listener: t }, i = rn.bind(r);
  return i.listener = t, r.wrapFn = i, i;
}
w.prototype.once = function(e, t) {
  return ye(t), this.on(e, at(this, e, t)), this;
};
w.prototype.prependOnceListener = function(e, t) {
  return ye(t), this.prependListener(e, at(this, e, t)), this;
};
w.prototype.removeListener = function(e, t) {
  var r, i, o, s, a;
  if (ye(t), i = this._events, i === void 0)
    return this;
  if (r = i[e], r === void 0)
    return this;
  if (r === t || r.listener === t)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, r.listener || t));
  else if (typeof r != "function") {
    for (o = -1, s = r.length - 1; s >= 0; s--)
      if (r[s] === t || r[s].listener === t) {
        a = r[s].listener, o = s;
        break;
      }
    if (o < 0)
      return this;
    o === 0 ? r.shift() : sn(r, o), r.length === 1 && (i[e] = r[0]), i.removeListener !== void 0 && this.emit("removeListener", e, a || t);
  }
  return this;
};
w.prototype.off = w.prototype.removeListener;
w.prototype.removeAllListeners = function(e) {
  var t, r, i;
  if (r = this._events, r === void 0)
    return this;
  if (r.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : r[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete r[e]), this;
  if (arguments.length === 0) {
    var o = Object.keys(r), s;
    for (i = 0; i < o.length; ++i)
      s = o[i], s !== "removeListener" && this.removeAllListeners(s);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = r[e], typeof t == "function")
    this.removeListener(e, t);
  else if (t !== void 0)
    for (i = t.length - 1; i >= 0; i--)
      this.removeListener(e, t[i]);
  return this;
};
function ut(n, e, t) {
  var r = n._events;
  if (r === void 0)
    return [];
  var i = r[e];
  return i === void 0 ? [] : typeof i == "function" ? t ? [i.listener || i] : [i] : t ? on(i) : lt(i, i.length);
}
w.prototype.listeners = function(e) {
  return ut(this, e, !0);
};
w.prototype.rawListeners = function(e) {
  return ut(this, e, !1);
};
w.listenerCount = function(n, e) {
  return typeof n.listenerCount == "function" ? n.listenerCount(e) : ct.call(n, e);
};
w.prototype.listenerCount = ct;
function ct(n) {
  var e = this._events;
  if (e !== void 0) {
    var t = e[n];
    if (typeof t == "function")
      return 1;
    if (t !== void 0)
      return t.length;
  }
  return 0;
}
w.prototype.eventNames = function() {
  return this._eventsCount > 0 ? le(this._events) : [];
};
function lt(n, e) {
  for (var t = new Array(e), r = 0; r < e; ++r)
    t[r] = n[r];
  return t;
}
function sn(n, e) {
  for (; e + 1 < n.length; e++)
    n[e] = n[e + 1];
  n.pop();
}
function on(n) {
  for (var e = new Array(n.length), t = 0; t < e.length; ++t)
    e[t] = n[t].listener || n[t];
  return e;
}
function an(n, e) {
  return new Promise(function(t, r) {
    function i(s) {
      n.removeListener(e, o), r(s);
    }
    function o() {
      typeof n.removeListener == "function" && n.removeListener("error", i), t([].slice.call(arguments));
    }
    ft(n, e, o, { once: !0 }), e !== "error" && un(n, i, { once: !0 });
  });
}
function un(n, e, t) {
  typeof n.on == "function" && ft(n, "error", e, t);
}
function ft(n, e, t, r) {
  if (typeof n.on == "function")
    r.once ? n.once(e, t) : n.on(e, t);
  else if (typeof n.addEventListener == "function")
    n.addEventListener(e, function i(o) {
      r.once && n.removeEventListener(e, i), t(o);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof n);
}
class N {
  constructor(e = {}, t = {}) {
    h(this, "__isClone");
    const { store: r, instanceDefaults: i } = this.Model;
    return Object.assign(this, i.call(this.Model, e, { models: te, store: r })), Object.defineProperty(this, "__isClone", {
      enumerable: !1,
      value: !!t.clone
    }), this;
  }
  static instanceDefaults(e) {
    return e;
  }
  static addEventListener(e, t) {
    return this.emitter.addListener(e, t), this;
  }
  static emit(e, ...t) {
    return this.emitter.emit(e, ...t);
  }
  static eventNames() {
    return this.emitter.eventNames();
  }
  static getMaxListeners() {
    return this.emitter.getMaxListeners();
  }
  static listenerCount(e) {
    return this.emitter.listenerCount(e);
  }
  static listeners(e) {
    return this.emitter.listeners(e);
  }
  static off(e, t) {
    return this.emitter.off(e, t), this;
  }
  static on(e, t) {
    return this.emitter.on(e, t), this;
  }
  static once(e, t) {
    return this.emitter.once(e, t), this;
  }
  static prependListener(e, t) {
    return this.emitter.prependListener(e, t), this;
  }
  static prependOnceListener(e, t) {
    return this.emitter.prependOnceListener(e, t), this;
  }
  static rawListeners(e) {
    return this.emitter.rawListeners(e);
  }
  static removeAllListeners(e) {
    return this.emitter.removeAllListeners(e), this;
  }
  static removeListener(e, t) {
    return this.emitter.removeListener(e, t), this;
  }
  static setMaxListeners(e) {
    return this.emitter.setMaxListeners(e), this;
  }
  static find(e) {
    return this.store.find(e);
  }
  static findInStore(e) {
    return this.store.findInStore(e);
  }
  static get(e, t) {
    return this.store.get(e, t);
  }
  static getFromStore(e, t) {
    return this.store.getFromStore(e, t);
  }
  static count(e) {
    return this.store.count(e);
  }
  static countInStore(e) {
    return this.store.countInStore(e);
  }
  static addToStore(e) {
    return this.store.addToStore(e);
  }
  static update(e, t, r) {
    return this.store.update(e, t, r);
  }
  static patch(e, t, r) {
    return this.store.patch(e, t, r);
  }
  static remove(e, t) {
    return this.store.remove(e, t);
  }
  static removeFromStore(e) {
    return this.store.removeFromStore(e);
  }
  get Model() {
    return this.constructor;
  }
  init(e) {
    const { instanceDefaults: t, setupInstance: r } = this.Model;
    t && Object.assign(this, t.call(this.Model, e), e), r && r.call(this.Model, this);
  }
  getId() {
    return $(this, this.Model.idField);
  }
  getTempId() {
    const { tempIdField: e } = this.Model;
    return K(this, e);
  }
  getAnyId() {
    const { tempIdField: e, idField: t } = this.Model;
    return ae(this, e, t);
  }
  get __isTemp() {
    const { idField: e } = this.Model;
    return $(this, e) == null;
  }
  get isSavePending() {
    const { store: e, idField: t } = this.Model, r = e.pendingById[$(this, t)];
    return (r == null ? void 0 : r.create) || (r == null ? void 0 : r.update) || (r == null ? void 0 : r.patch) || !1;
  }
  get isCreatePending() {
    var r;
    const { store: e, idField: t } = this.Model;
    return ((r = e.pendingById[$(this, t)]) == null ? void 0 : r.create) || !1;
  }
  get isPatchPending() {
    var r;
    const { store: e, idField: t } = this.Model;
    return ((r = e.pendingById[$(this, t)]) == null ? void 0 : r.patch) || !1;
  }
  get isUpdatePending() {
    var r;
    const { store: e, idField: t } = this.Model;
    return ((r = e.pendingById[$(this, t)]) == null ? void 0 : r.update) || !1;
  }
  get isRemovePending() {
    var r;
    const { store: e, idField: t } = this.Model;
    return ((r = e.pendingById[$(this, t)]) == null ? void 0 : r.remove) || !1;
  }
  get isPending() {
    const { store: e, idField: t } = this.Model, r = e.pendingById[$(this, t)];
    return (r == null ? void 0 : r.create) || (r == null ? void 0 : r.update) || (r == null ? void 0 : r.patch) || (r == null ? void 0 : r.remove) || !1;
  }
  addToStore() {
    const { store: e } = this.Model;
    return e.addToStore(this);
  }
  clone(e, t = {}) {
    const { store: r } = this.Model;
    return r.clone(this, e, t);
  }
  commit(e) {
    const { store: t } = this.Model;
    if (this.__isClone)
      return t.commit(this, e);
    throw new Error("You cannot call commit on a non-copy");
  }
  reset(e = {}) {
    const { store: t } = this.Model;
    return t.reset(this, e);
  }
  save(e) {
    const { idField: t } = this.Model;
    return $(this, t) != null ? this.patch(e) : this.create(e);
  }
  async create(e) {
    const { idField: t, store: r } = this.Model, i = Object.assign({}, this);
    i[t] === null && delete i[t];
    const { __isClone: o } = this, s = await r.create(i, e);
    return Object.assign(this, s), o ? s.clone() : s;
  }
  async patch(e = {}) {
    const { idField: t, store: r } = this.Model, i = $(this, t);
    if (i == null) {
      const a = new Error(
        `Missing ${t} property. You must create the data before you can patch with this data`
      );
      return Promise.reject(a);
    }
    const { __isClone: o } = this;
    let s;
    if (o && e.diff != !1) {
      const a = this.Model.getFromStore(i), u = zt(a, this, e.diff), c = Q(a);
      if (e.commit !== !1 && this.commit(u), e.with) {
        const l = Ee(this, e.with);
        typeof e.with != "string" && !Array.isArray(e.with) && Object.assign(l, e.with), Object.assign(u, l);
      }
      if (Object.keys(u).length === 0)
        return this;
      try {
        s = await r.patch(i, u, e);
      } catch {
        this.commit(c);
      }
    } else
      s = await r.patch(i, this, e);
    return o ? s.clone() : s;
  }
  async update(e) {
    const { idField: t, store: r } = this.Model, i = $(this, t);
    if (i == null) {
      const a = new Error(
        `Missing ${t} property. You must create the data before you can patch with this data`
      );
      return Promise.reject(a);
    }
    const { __isClone: o } = this, s = await r.update(i, this, e);
    return o ? s.clone() : s;
  }
  remove(e) {
    cn(this);
    const { idField: t, store: r } = this.Model, i = $(this, t);
    return r.remove(i, e);
  }
  removeFromStore() {
    const { store: e } = this.Model;
    return e.removeFromStore(this);
  }
}
h(N, "store"), h(N, "models", te), h(N, "pinia", null), h(N, "servicePath", ""), h(N, "idField", ""), h(N, "modelName", ""), h(N, "tempIdField", ""), h(N, "associations", {}), h(N, "emitter", new Ae.exports.EventEmitter());
function cn(n) {
  if (!n)
    throw new Error(
      `Instance methods must be called with the dot operator. If you are referencing one in an event, use '@click="() => instance.remove()"' so that the correct 'this' context is applied. Using '@click="instance.remove"' will call the remove function with "this" set to 'undefined' because the function is called directly instead of as a method.`
    );
}
const ee = {};
function dt(n, e) {
  ee[n] || (ee[n] = e);
}
var he = ln;
function ln(n, e, t, r) {
  var i, o, s;
  return function() {
    if (s = this, o = Array.prototype.slice.call(arguments), i && (t || r))
      return;
    if (!t)
      return c(), i = setTimeout(u, e), i;
    i = setTimeout(c, e), n.apply(s, o);
    function u() {
      c(), n.apply(s, o);
    }
    function c() {
      clearTimeout(i), i = null;
    }
  };
}
function fn({ service: n, Model: e, store: t, options: r }) {
  const i = {
    addOrUpdateById: {},
    removeItemById: {},
    enqueueAddOrUpdate(s) {
      const a = $(s, r.idField);
      this.addOrUpdateById[a] = s, D(this.removeItemById, a) && delete this.removeItemById[a], this.flushAddOrUpdateQueue();
    },
    enqueueRemoval(s) {
      const a = $(s, r.idField);
      this.removeItemById[a] = s, D(this.addOrUpdateById, a) && delete this.addOrUpdateById[a], this.flushRemoveItemQueue();
    },
    flushAddOrUpdateQueue: he(
      async function() {
        const s = Object.values(this.addOrUpdateById);
        s.length !== 0 && (await t.addOrUpdate(s), this.addOrUpdateById = {});
      },
      r.debounceEventsTime || 20,
      void 0,
      r.debounceEventsGuarantee
    ),
    flushRemoveItemQueue: he(
      function() {
        const s = Object.values(this.removeItemById);
        s.length !== 0 && (t.removeFromStore(s), this.removeItemById = {});
      },
      r.debounceEventsTime || 20,
      void 0,
      r.debounceEventsGuarantee
    )
  }, o = (s, a) => {
    const u = r.handleEvents[s], c = u(a, { model: e, models: te }), [l, f = a] = Array.isArray(c) ? c : [c];
    l && (r.debounceEventsTime ? s === "removed" ? i.enqueueRemoval(a) : i.enqueueAddOrUpdate(a) : s === "removed" ? t.removeFromStore(f) : t.addOrUpdate(f));
  };
  return n.on("created", (s) => {
    o("created", s), e.emit && e.emit("created", s);
  }), n.on("updated", (s) => {
    o("updated", s), e.emit && e.emit("updated", s);
  }), n.on("patched", (s) => {
    o("patched", s), e.emit && e.emit("patched", s);
  }), n.on("removed", (s) => {
    o("removed", s), e.emit && e.emit("removed", s);
  }), i;
}
function dn(n) {
  const e = {
    clientAlias: n.clientAlias,
    servicePath: n.servicePath,
    idField: n.idField,
    tempIdField: n.tempIdField,
    itemsById: {},
    tempsById: {},
    clonesById: {},
    pendingById: {
      Model: {
        find: !1,
        count: !1,
        get: !1
      }
    },
    eventLocksById: {
      created: {},
      patched: {},
      updated: {},
      removed: {}
    },
    pagination: {},
    whitelist: n.whitelist,
    paramsForServer: n.paramsForServer,
    skipRequestIfExists: n.skipRequestIfExists
  }, t = n.state();
  return () => Object.assign(e, t);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var je = function(n, e) {
  return je = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, r) {
    t.__proto__ = r;
  } || function(t, r) {
    for (var i in r)
      Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);
  }, je(n, e);
};
function _(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  je(n, e);
  function t() {
    this.constructor = n;
  }
  n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var xe = function(n) {
  var e = "[object " + n + "]";
  return function(t) {
    return hn(t) === e;
  };
}, hn = function(n) {
  return Object.prototype.toString.call(n);
}, ie = function(n) {
  return n instanceof Date ? n.getTime() : se(n) ? n.map(ie) : n && typeof n.toJSON == "function" ? n.toJSON() : n;
}, se = xe("Array"), pn = xe("Object"), vn = xe("Function"), mn = function(n) {
  return n && (n.constructor === Object || n.constructor === Array || n.constructor.toString() === "function Object() { [native code] }" || n.constructor.toString() === "function Array() { [native code] }") && !n.toJSON;
}, Fe = function(n, e) {
  if (n == null && n == e || n === e)
    return !0;
  if (Object.prototype.toString.call(n) !== Object.prototype.toString.call(e))
    return !1;
  if (se(n)) {
    if (n.length !== e.length)
      return !1;
    for (var t = 0, r = n.length; t < r; t++)
      if (!Fe(n[t], e[t]))
        return !1;
    return !0;
  } else if (pn(n)) {
    if (Object.keys(n).length !== Object.keys(e).length)
      return !1;
    for (var i in n)
      if (!Fe(n[i], e[i]))
        return !1;
    return !0;
  }
  return !1;
}, Le = function(n, e, t, r, i, o) {
  var s = e[r];
  if (se(n) && isNaN(Number(s))) {
    for (var a = 0, u = n.length; a < u; a++)
      if (!Le(n[a], e, t, r, a, n))
        return !1;
  }
  return r === e.length || n == null ? t(n, i, o, r === 0) : Le(n[s], e, t, r + 1, s, n);
}, R = function() {
  function n(e, t, r, i) {
    this.params = e, this.owneryQuery = t, this.options = r, this.name = i, this.init();
  }
  return n.prototype.init = function() {
  }, n.prototype.reset = function() {
    this.done = !1, this.keep = !1;
  }, n;
}(), Me = function(n) {
  _(e, n);
  function e(t, r, i, o) {
    var s = n.call(this, t, r, i) || this;
    return s.children = o, s;
  }
  return e.prototype.reset = function() {
    this.keep = !1, this.done = !1;
    for (var t = 0, r = this.children.length; t < r; t++)
      this.children[t].reset();
  }, e.prototype.childrenNext = function(t, r, i, o) {
    for (var s = !0, a = !0, u = 0, c = this.children.length; u < c; u++) {
      var l = this.children[u];
      if (l.done || l.next(t, r, i, o), l.keep || (a = !1), l.done) {
        if (!l.keep)
          break;
      } else
        s = !1;
    }
    this.done = s, this.keep = a;
  }, e;
}(R), ht = function(n) {
  _(e, n);
  function e(t, r, i, o, s) {
    var a = n.call(this, t, r, i, o) || this;
    return a.name = s, a;
  }
  return e;
}(Me), yn = function(n) {
  _(e, n);
  function e() {
    var t = n !== null && n.apply(this, arguments) || this;
    return t.propop = !0, t;
  }
  return e.prototype.next = function(t, r, i, o) {
    this.childrenNext(t, r, i, o);
  }, e;
}(Me), qe = function(n) {
  _(e, n);
  function e(t, r, i, o, s) {
    var a = n.call(this, r, i, o, s) || this;
    return a.keyPath = t, a.propop = !0, a._nextNestedValue = function(u, c, l, f) {
      return a.childrenNext(u, c, l, f), !a.done;
    }, a;
  }
  return e.prototype.next = function(t, r, i) {
    Le(t, this.keyPath, this._nextNestedValue, 0, r, i);
  }, e;
}(Me), Ce = function(n, e) {
  if (n instanceof Function)
    return n;
  if (n instanceof RegExp)
    return function(r) {
      var i = typeof r == "string" && n.test(r);
      return n.lastIndex = 0, i;
    };
  var t = ie(n);
  return function(r) {
    return e(t, ie(r));
  };
}, J = function(n) {
  _(e, n);
  function e() {
    var t = n !== null && n.apply(this, arguments) || this;
    return t.propop = !0, t;
  }
  return e.prototype.init = function() {
    this._test = Ce(this.params, this.options.compare);
  }, e.prototype.next = function(t, r, i) {
    (!Array.isArray(i) || i.hasOwnProperty(r)) && this._test(t, r, i) && (this.done = !0, this.keep = !0);
  }, e;
}(R), ge = function(n, e, t) {
  return new J(n, e, t);
}, gn = function(n) {
  _(e, n);
  function e() {
    var t = n !== null && n.apply(this, arguments) || this;
    return t.propop = !0, t;
  }
  return e.prototype.next = function() {
    this.done = !0, this.keep = !1;
  }, e;
}(R), In = function(n) {
  return function(e, t, r, i) {
    return e == null ? new gn(e, t, r, i) : n(e, t, r, i);
  };
}, Ie = function(n) {
  return In(function(e, t, r, i) {
    var o = typeof ie(e), s = n(e);
    return new J(function(a) {
      return typeof ie(a) === o && s(a);
    }, t, r, i);
  });
}, On = function(n, e, t, r) {
  var i = r.operations[n];
  return i || pt(n), i(e, t, r, n);
}, pt = function(n) {
  throw new Error("Unsupported operation: " + n);
}, vt = function(n, e) {
  for (var t in n)
    if (e.operations.hasOwnProperty(t) || t.charAt(0) === "$")
      return !0;
  return !1;
}, wn = function(n, e, t, r, i) {
  if (vt(e, i)) {
    var o = mt(e, t, i), s = o[0], a = o[1];
    if (a.length)
      throw new Error("Property queries must contain only operations, or exact objects.");
    return new qe(n, e, r, i, s);
  }
  return new qe(n, e, r, i, [
    new J(e, r, i)
  ]);
}, oe = function(n, e, t) {
  e === void 0 && (e = null);
  var r = t === void 0 ? {} : t, i = r.compare, o = r.operations, s = {
    compare: i || Fe,
    operations: Object.assign({}, o || {})
  }, a = mt(n, null, s), u = a[0], c = a[1], l = [];
  return u.length && l.push(new qe([], n, e, s, u)), l.push.apply(l, c), l.length === 1 ? l[0] : new yn(n, e, s, l);
}, mt = function(n, e, t) {
  var r = [], i = [];
  if (!mn(n))
    return r.push(new J(n, n, t)), [r, i];
  for (var o in n)
    if (t.operations.hasOwnProperty(o)) {
      var s = On(o, n[o], n, t);
      if (s && !s.propop && e && !t.operations[e])
        throw new Error("Malformed query. " + o + " cannot be matched against property.");
      s != null && r.push(s);
    } else
      o.charAt(0) === "$" ? pt(o) : i.push(wn(o.split("."), n[o], o, n, t));
  return [r, i];
}, Sn = function(n) {
  return function(e, t, r) {
    return n.reset(), n.next(e, t, r), n.keep;
  };
}, bn = function(n) {
  _(e, n);
  function e() {
    var t = n !== null && n.apply(this, arguments) || this;
    return t.propop = !0, t;
  }
  return e.prototype.init = function() {
    this._test = Ce(this.params, this.options.compare);
  }, e.prototype.reset = function() {
    n.prototype.reset.call(this), this.keep = !0;
  }, e.prototype.next = function(t) {
    this._test(t) && (this.done = !0, this.keep = !1);
  }, e;
}(R), Pn = function(n) {
  _(e, n);
  function e() {
    var t = n !== null && n.apply(this, arguments) || this;
    return t.propop = !0, t;
  }
  return e.prototype.init = function() {
    if (!this.params || typeof this.params != "object")
      throw new Error("Malformed query. $elemMatch must by an object.");
    this._queryOperation = oe(this.params, this.owneryQuery, this.options);
  }, e.prototype.reset = function() {
    n.prototype.reset.call(this), this._queryOperation.reset();
  }, e.prototype.next = function(t) {
    if (se(t)) {
      for (var r = 0, i = t.length; r < i; r++) {
        this._queryOperation.reset();
        var o = t[r];
        this._queryOperation.next(o, r, t, !1), this.keep = this.keep || this._queryOperation.keep;
      }
      this.done = !0;
    } else
      this.done = !1, this.keep = !1;
  }, e;
}(R), $n = function(n) {
  _(e, n);
  function e() {
    var t = n !== null && n.apply(this, arguments) || this;
    return t.propop = !0, t;
  }
  return e.prototype.init = function() {
    this._queryOperation = oe(this.params, this.owneryQuery, this.options);
  }, e.prototype.reset = function() {
    n.prototype.reset.call(this), this._queryOperation.reset();
  }, e.prototype.next = function(t, r, i, o) {
    this._queryOperation.next(t, r, i, o), this.done = this._queryOperation.done, this.keep = !this._queryOperation.keep;
  }, e;
}(R), yt = function(n) {
  _(e, n);
  function e() {
    var t = n !== null && n.apply(this, arguments) || this;
    return t.propop = !0, t;
  }
  return e.prototype.init = function() {
  }, e.prototype.next = function(t) {
    se(t) && t.length === this.params && (this.done = !0, this.keep = !0);
  }, e;
}(R), gt = function(n) {
  if (n.length === 0)
    throw new Error("$and/$or/$nor must be a nonempty array");
}, It = function(n) {
  _(e, n);
  function e() {
    var t = n !== null && n.apply(this, arguments) || this;
    return t.propop = !1, t;
  }
  return e.prototype.init = function() {
    var t = this;
    gt(this.params), this._ops = this.params.map(function(r) {
      return oe(r, null, t.options);
    });
  }, e.prototype.reset = function() {
    this.done = !1, this.keep = !1;
    for (var t = 0, r = this._ops.length; t < r; t++)
      this._ops[t].reset();
  }, e.prototype.next = function(t, r, i) {
    for (var o = !1, s = !1, a = 0, u = this._ops.length; a < u; a++) {
      var c = this._ops[a];
      if (c.next(t, r, i), c.keep) {
        o = !0, s = c.keep;
        break;
      }
    }
    this.keep = s, this.done = o;
  }, e;
}(R), En = function(n) {
  _(e, n);
  function e() {
    var t = n !== null && n.apply(this, arguments) || this;
    return t.propop = !1, t;
  }
  return e.prototype.next = function(t, r, i) {
    n.prototype.next.call(this, t, r, i), this.keep = !this.keep;
  }, e;
}(It), Ot = function(n) {
  _(e, n);
  function e() {
    var t = n !== null && n.apply(this, arguments) || this;
    return t.propop = !0, t;
  }
  return e.prototype.init = function() {
    var t = this;
    this._testers = this.params.map(function(r) {
      if (vt(r, t.options))
        throw new Error("cannot nest $ under " + t.name.toLowerCase());
      return Ce(r, t.options.compare);
    });
  }, e.prototype.next = function(t, r, i) {
    for (var o = !1, s = !1, a = 0, u = this._testers.length; a < u; a++) {
      var c = this._testers[a];
      if (c(t)) {
        o = !0, s = !0;
        break;
      }
    }
    this.keep = s, this.done = o;
  }, e;
}(R), kn = function(n) {
  _(e, n);
  function e(t, r, i, o) {
    var s = n.call(this, t, r, i, o) || this;
    return s.propop = !0, s._in = new Ot(t, r, i, o), s;
  }
  return e.prototype.next = function(t, r, i, o) {
    this._in.next(t, r, i), se(i) && !o ? this._in.keep ? (this.keep = !1, this.done = !0) : r == i.length - 1 && (this.keep = !0, this.done = !0) : (this.keep = !this._in.keep, this.done = !0);
  }, e.prototype.reset = function() {
    n.prototype.reset.call(this), this._in.reset();
  }, e;
}(R), jn = function(n) {
  _(e, n);
  function e() {
    var t = n !== null && n.apply(this, arguments) || this;
    return t.propop = !0, t;
  }
  return e.prototype.next = function(t, r, i) {
    i.hasOwnProperty(r) === this.params && (this.done = !0, this.keep = !0);
  }, e;
}(R), Fn = function(n) {
  _(e, n);
  function e(t, r, i, o) {
    var s = n.call(this, t, r, i, t.map(function(a) {
      return oe(a, r, i);
    }), o) || this;
    return s.propop = !1, gt(t), s;
  }
  return e.prototype.next = function(t, r, i, o) {
    this.childrenNext(t, r, i, o);
  }, e;
}(ht), Ln = function(n) {
  _(e, n);
  function e(t, r, i, o) {
    var s = n.call(this, t, r, i, t.map(function(a) {
      return oe(a, r, i);
    }), o) || this;
    return s.propop = !0, s;
  }
  return e.prototype.next = function(t, r, i, o) {
    this.childrenNext(t, r, i, o);
  }, e;
}(ht), qn = function(n, e, t) {
  return new J(n, e, t);
}, _n = function(n, e, t, r) {
  return new bn(n, e, t, r);
}, Bn = function(n, e, t, r) {
  return new It(n, e, t, r);
}, An = function(n, e, t, r) {
  return new En(n, e, t, r);
}, xn = function(n, e, t, r) {
  return new Pn(n, e, t, r);
}, Mn = function(n, e, t, r) {
  return new kn(n, e, t, r);
}, Cn = function(n, e, t, r) {
  return new Ot(n, e, t, r);
}, Tn = Ie(function(n) {
  return function(e) {
    return e < n;
  };
}), Nn = Ie(function(n) {
  return function(e) {
    return e <= n;
  };
}), Rn = Ie(function(n) {
  return function(e) {
    return e > n;
  };
}), Un = Ie(function(n) {
  return function(e) {
    return e >= n;
  };
}), Wn = function(n, e, t) {
  var r = n[0], i = n[1];
  return new J(function(o) {
    return ie(o) % r === i;
  }, e, t);
}, Dn = function(n, e, t, r) {
  return new jn(n, e, t, r);
}, Gn = function(n, e, t) {
  return new J(new RegExp(n, e.$options), e, t);
}, Qn = function(n, e, t, r) {
  return new $n(n, e, t, r);
}, Ke = {
  number: function(n) {
    return typeof n == "number";
  },
  string: function(n) {
    return typeof n == "string";
  },
  bool: function(n) {
    return typeof n == "boolean";
  },
  array: function(n) {
    return Array.isArray(n);
  },
  null: function(n) {
    return n === null;
  },
  timestamp: function(n) {
    return n instanceof Date;
  }
}, Jn = function(n, e, t) {
  return new J(function(r) {
    if (typeof n == "string") {
      if (!Ke[n])
        throw new Error("Type alias does not exist");
      return Ke[n](r);
    }
    return r != null ? r instanceof n || r.constructor === n : !1;
  }, e, t);
}, Kn = function(n, e, t, r) {
  return new Fn(n, e, t, r);
}, Vn = function(n, e, t, r) {
  return new Ln(n, e, t, r);
}, Yn = function(n, e, t) {
  return new yt(n, e, t, "$size");
}, Hn = function() {
  return null;
}, zn = function(n, e, t) {
  var r;
  if (vn(n))
    r = n;
  else if (!process.env.CSP_ENABLED)
    r = new Function("obj", "return " + n);
  else
    throw new Error('In CSP mode, sift does not support strings in "$where" condition');
  return new J(function(i) {
    return r.bind(i)(i);
  }, e, t);
}, Xn = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  $Size: yt,
  $eq: qn,
  $ne: _n,
  $or: Bn,
  $nor: An,
  $elemMatch: xn,
  $nin: Mn,
  $in: Cn,
  $lt: Tn,
  $lte: Nn,
  $gt: Rn,
  $gte: Un,
  $mod: Wn,
  $exists: Dn,
  $regex: Gn,
  $not: Qn,
  $type: Jn,
  $and: Kn,
  $all: Vn,
  $size: Yn,
  $options: Hn,
  $where: zn
}), Zn = function(n, e, t) {
  var r = t === void 0 ? {} : t, i = r.compare, o = r.operations;
  return oe(n, e, {
    compare: i,
    operations: Object.assign({}, Xn, o || {})
  });
}, er = function(n, e) {
  e === void 0 && (e = {});
  var t = Zn(n, null, e);
  return Sn(t);
};
const tr = er;
function Te(n, e, t = "g") {
  const r = ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\"];
  return e = e.replace(new RegExp(`(\\${r.join("|\\")})`, t), "\\$1"), e = e.replace(/%/g, ".*").replace(/_/g, "."), RegExp(`^${e}$`, t).test(n);
}
function wt(n, e) {
  return Te(n, e, "ig");
}
const nr = (n, e, t) => ge((r) => Te(r, n), e, t), rr = (n, e, t) => ge((r) => !Te(r, n), e, t), Ve = (n, e, t) => ge((r) => wt(r, n), e, t), ir = (n, e, t) => ge((r) => !wt(r, n), e, t), sr = {
  $like: nr,
  $notLike: rr,
  $ilike: Ve,
  $iLike: Ve,
  $notILike: ir
}, or = ["$sort", "$limit", "$skip", "$select"], ar = ["$elemMatch"];
function ur(n) {
  return Object.assign({
    service() {
      const t = n.clients[this.clientAlias];
      if (!t)
        throw new Error(
          `There is no registered FeathersClient named '${this.clientAlias}'. You need to provide one in the 'defineStore' options.`
        );
      return t.service(this.servicePath);
    },
    Model() {
      return n.Model;
    },
    isSsr() {
      return !!b(n.ssr);
    },
    itemIds() {
      return this.items.map((t) => t[this.idField]);
    },
    items() {
      return Object.values(this.itemsById);
    },
    tempIds() {
      return this.temps.map((t) => t[this.tempIdField]);
    },
    temps() {
      return Object.values(this.tempsById);
    },
    cloneIds() {
      return this.clones.map((t) => t[this.idField]);
    },
    clones() {
      return Object.values(this.clonesById);
    },
    findInStore() {
      return (t) => {
        var f, d;
        t = { ...b(t) };
        const { paramsForServer: r, whitelist: i, itemsById: o } = this, s = k.omit(t.query || {}, ...r), { query: a, filters: u } = Ft(s, {
          filters: {
            $and: !0,
            $or: !0
          },
          operators: ar.concat(i || []).concat(["$like", "$iLike", "$ilike", "$notLike", "$notILike"]).concat(((f = this.service.options) == null ? void 0 : f.allow) || ((d = this.service.options) == null ? void 0 : d.whitelist) || [])
        });
        u.$or && (a.$or = u.$or), u.$and && (a.$and = u.$and);
        let c = k.values(o);
        t.temps && c.push(...k.values(this.tempsById)), c = c.filter(tr(a, { operations: sr }));
        const l = c.length;
        return u.$sort && c.sort(Lt(u.$sort)), u.$skip && (c = c.slice(u.$skip)), typeof u.$limit < "u" && (c = c.slice(0, u.$limit)), c = c.map((v) => (v && !v.constructor.modelName && (v = this.addOrUpdate(v)), v)), {
          total: l,
          limit: u.$limit || 0,
          skip: u.$skip || 0,
          data: c
        };
      };
    },
    countInStore() {
      return (t) => {
        if (t = { ...b(t) }, !t.query)
          throw "params must contain a query-object";
        return t.query = k.omit(t.query, ...or), this.findInStore(t).total;
      };
    },
    getFromStore() {
      return (t, r = {}) => {
        t = b(t), r = Q(b(r) || {});
        let i = null;
        const o = this.itemsById[t] && Ne(r, this.idField)(this.itemsById[t]), s = this.tempsById[t] && Ne(r, this.tempIdField)(this.tempsById[t]);
        return o ? i = o : s && (i = s), i && !i.constructor.modelName && (i = this.addOrUpdate(i)), i;
      };
    },
    isCreatePending() {
      return ue("create", this);
    },
    isPatchPending() {
      return ue("patch", this);
    },
    isUpdatePending() {
      return ue("update", this);
    },
    isRemovePending() {
      return ue("remove", this);
    }
  }, n.getters);
}
function ue(n, e) {
  return Object.keys(e.pendingById).reduce((r, i) => e.pendingById[i][n] || r, !1);
}
const St = (n, e, t) => {
  const r = p(() => t.value ? Math.ceil(t.value / n.value) : 1), i = p({
    set(d) {
      d < 1 ? d = 1 : d > r.value && (d = r.value);
      const v = n.value * Math.floor(d - 1);
      e.value = v;
    },
    get() {
      return r.value === 0 ? 0 : Math.floor(e.value / n.value + 1);
    }
  }), o = p(() => i.value - 1 > 0), s = p(() => i.value < r.value);
  return { pageCount: r, currentPage: i, canPrev: o, canNext: s, toStart: () => Promise.resolve(i.value = 1), toEnd: () => Promise.resolve(i.value = r.value), toPage: (d) => Promise.resolve(i.value = d), next: () => Promise.resolve(i.value++), prev: () => Promise.resolve(i.value--) };
};
function bt(n) {
  return new Pt(n);
}
class Pt {
  constructor(e) {
    h(this, "params");
    h(this, "onServer");
    h(this, "isSsr");
    h(this, "qid");
    h(this, "data");
    h(this, "allData");
    h(this, "total");
    h(this, "limit");
    h(this, "skip");
    h(this, "findInStore");
    h(this, "currentQuery");
    h(this, "latestQuery");
    h(this, "previousQuery");
    h(this, "find");
    h(this, "request");
    h(this, "requestCount");
    h(this, "queryWhen");
    h(this, "isPending");
    h(this, "haveBeenRequested");
    h(this, "haveLoaded");
    h(this, "error");
    h(this, "clearError");
    h(this, "pageCount");
    h(this, "currentPage");
    h(this, "canPrev");
    h(this, "canNext");
    h(this, "next");
    h(this, "prev");
    h(this, "toStart");
    h(this, "toEnd");
    h(this, "toPage");
    let t;
    de(e) && (t = e);
    const r = b(e).store, i = Pe(e) ? de(e) ? j(e.value) : e : j(e);
    delete i.value.store, this.params = i, this.qid = Z(i.value, "qid"), this.qid.value || (this.qid.value = "default");
    const { immediate: o = !0, watch: s = !1 } = i.value, a = Z(this.params, "query");
    this.limit = Z(a, "$limit"), this.skip = Z(a, "$skip");
    const u = p(() => ({
      ...i.value,
      $limit: this.limit.value,
      $skip: this.skip.value
    })), c = p(() => {
      const P = { ...i.value.query || {} }, { $limit: x, $skip: E, ...C } = P;
      return { ...i.value, query: C };
    });
    this.onServer = !!i.value.onServer, this.isSsr = p(() => r.isSsr);
    const l = j(!1), f = j(!1), d = j(!1), v = j(null);
    this.isPending = p(() => l.value), this.haveBeenRequested = p(() => f.value), this.haveLoaded = p(() => d.value), this.error = p(() => v.value), this.clearError = () => v.value = null, this.data = p(() => {
      if (l.value && this.latestQuery.value && this.onServer) {
        const { pageParams: P, queryParams: x } = this.latestQuery.value, E = { query: { ...P, ...x }, onServer: !0 };
        return ke(r, E).value;
      }
      return ke(r, u).value;
    }), this.allData = p(() => {
      var G, S;
      if (this.currentQuery == null)
        return [];
      const P = Object.keys(k.omit((G = this.currentQuery.value) == null ? void 0 : G.queryState, "total", "queryParams")), E = Object.values(k.pick((S = this.currentQuery.value) == null ? void 0 : S.queryState, ...P)).reduce((q, X) => (X.ids.forEach((Oe) => {
        q.includes(Oe) || q.push(Oe);
      }), q), []), C = k.pick(r.itemsById, ...E);
      return Object.values(C);
    }), this.findInStore = r.findInStore;
    let I = () => !0;
    this.queryWhen = (P) => {
      I = P;
    }, this.currentQuery = p(() => {
      const P = r.pagination[this.qid.value];
      if (!P)
        return null;
      const x = V(i.value);
      delete x.response, delete x.isOutdated;
      const E = P[x.queryId];
      if (!E)
        return null;
      const { total: C } = E, G = E[x.pageId];
      if (!G)
        return null;
      const { ids: S, queriedAt: q } = G, X = Object.values(k.pick(r.itemsById, ...S));
      return { ...x, ids: S, items: X, total: C, queriedAt: q, queryState: E } || null;
    });
    const m = j([]);
    this.latestQuery = p(() => m.value[m.value.length - 1] || null), this.previousQuery = p(() => m.value[m.value.length - 2] || null);
    const y = p(() => r.countInStore(c.value));
    this.total = p(() => {
      var P;
      return this.onServer ? (P = this.latestQuery.value) == null ? void 0 : P.response.total : y.value;
    });
    const g = St(this.limit, this.skip, this.total), { pageCount: O, currentPage: L, canPrev: B, canNext: M } = g;
    Object.assign(this, { pageCount: O, currentPage: L, canPrev: B, canNext: M });
    const A = async () => {
      U.value && await U.value;
    };
    this.toStart = () => A().then(() => g.toStart()).then(() => W()), this.toEnd = () => A().then(() => g.toEnd()).then(() => W()), this.toPage = (P) => A().then(() => g.toPage(P)).then(() => W()), this.next = () => A().then(() => g.next()).then(() => W()), this.prev = () => A().then(() => g.prev()).then(() => W()), this.requestCount = j(0), this.request = j(null), this.find = async (P = u) => {
      const x = b(P);
      if (!I())
        return Promise.resolve({ data: [] });
      this.requestCount.value++, f.value = !0, l.value = !0, d.value = !1, v.value = null;
      try {
        const E = await r.find(x);
        if (D(E, "limit") && this.limit.value == null || this.skip.value == null) {
          const C = E;
          this.limit.value === void 0 && (this.limit.value = C.limit), this.skip.value === void 0 && (this.skip.value = C.skip);
        }
        if (E.total) {
          const G = V(u, E);
          m.value.push(G), m.value.length > 2 && m.value.shift();
        }
        return d.value = !0, E;
      } catch (E) {
        throw v.value = E, E;
      } finally {
        l.value = !1;
      }
    };
    let T = !1;
    const U = this.request;
    (this.limit.value || this.skip.value) && (T = !0);
    const W = async (P) => {
      if (!!this.onServer) {
        if (this.requestCount.value === 1 && !T && !t) {
          T = !0;
          return;
        }
        U.value = this.find(P || i), await U.value;
      }
    };
    if (this.onServer)
      if (t) {
        let P;
        Y(t, (E) => {
          if (E == null)
            return;
          const C = Zt(E);
          $e(k.omit(C, "store"), k.omit(P, "store")) || (P = C, en(i, C), W());
        }, { immediate: o });
      } else
        s && !t ? Y(c, () => W(), { immediate: o }) : (!s && o || o && (this.limit.value == null || this.limit.value == null)) && W();
    return this;
  }
}
function Ye(n, e) {
  return new cr(n, e);
}
class cr {
  constructor(e, t) {
    h(this, "id");
    h(this, "params");
    h(this, "isSsr");
    h(this, "data");
    h(this, "ids");
    h(this, "getFromStore");
    h(this, "get");
    h(this, "request");
    h(this, "requestCount");
    h(this, "queryWhen");
    h(this, "isPending");
    h(this, "hasBeenRequested");
    h(this, "hasLoaded");
    h(this, "error");
    h(this, "clearError");
    const r = b(t).store, i = Pe(e) ? de(e) ? j(e.value) : e : j(e), o = Pe(t) ? de(t) ? j(t.value) : t : j(t);
    delete o.value.store, this.id = i, this.params = o;
    const { immediate: s = !0, watch: a = !0, onServer: u = !1 } = o.value;
    this.isSsr = p(() => r.isSsr);
    const c = j(!1), l = j(!1), f = j(!1), d = j(null);
    this.isPending = p(() => c.value), this.hasBeenRequested = p(() => l.value), this.hasLoaded = p(() => f.value), this.error = p(() => d.value), this.clearError = () => d.value = null, this.ids = j([]);
    const v = p(() => this.ids.value.length && this.ids.value[this.ids.value.length - 1]);
    this.data = p(() => c.value && v.value != null ? r.getFromStore(v.value, o) || null : r.getFromStore(i.value, o) || null), this.getFromStore = r.getFromStore;
    let I = () => !0;
    this.queryWhen = (g) => {
      I = g;
    }, this.requestCount = j(0), this.request = j(null), this.get = async (g, O) => {
      const L = b(g || i), B = b(O);
      if (!!I()) {
        if (L == null)
          throw new Error("id is required for feathers-pinia get requests");
        this.requestCount.value++, l.value = !0, c.value = !0, f.value = !1, d.value = null;
        try {
          const M = await r.get(L, B);
          return M && L && this.ids.value.push(L), f.value = !0, M;
        } catch (M) {
          throw d.value = M, M;
        } finally {
          c.value = !1;
        }
      }
    };
    const m = this.request, y = async (g, O) => {
      !g || (m.value = this.get(g, O), await m.value);
    };
    return u && a && Y(
      i,
      async () => {
        await y(i, o);
      },
      { immediate: s }
    ), this;
  }
}
function lr({
  model: n,
  params: e = p(() => null),
  fetchParams: t = p(() => {
  }),
  qid: r = "default",
  queryWhen: i = p(() => !0),
  local: o = !1,
  immediate: s = !0
}) {
  if (!n)
    throw new Error("No model provided for useFind(). Did you define and register it with FeathersPinia?");
  const a = (m) => {
    const y = b(m), g = b(t);
    return y || y === null ? y : g || g === null ? g : b(e);
  }, u = ve({
    qid: r,
    isPending: !1,
    haveBeenRequested: !1,
    haveLoaded: o,
    error: null,
    debounceTime: null,
    latestQuery: null,
    isLocal: o,
    request: null
  }), c = {
    items: ke(n.store || n, e),
    paginationData: p(() => n.store.pagination),
    servicePath: p(() => n.servicePath),
    isSsr: p(() => n.store.isSsr)
  };
  function l(m, y) {
    const g = b(m);
    if (typeof g == "function") {
      const O = V(y, {}), L = n.store.pagination[O.qid], B = L == null ? void 0 : L[O.queryId], M = B == null ? void 0 : B[O.pageId], A = {
        items: c.items,
        queryInfo: O,
        qidData: L,
        queryData: B,
        pageData: M,
        isPending: p(() => u.isPending),
        haveBeenRequested: p(() => u.haveBeenRequested),
        haveLoaded: p(() => u.haveLoaded),
        error: p(() => u.error)
      };
      return g(A);
    }
    return g;
  }
  function f(m) {
    if (u.isLocal)
      return;
    m = b(m), u.isPending = !0, u.haveBeenRequested = !0;
    const y = n.find(m).then((g) => {
      if (u.error = null, u.haveLoaded = !0, !Array.isArray(g)) {
        const O = V(m, g);
        O.isOutdated = !1, u.latestQuery = O;
      }
      return u.isPending = !1, g;
    });
    return u.request = y, y;
  }
  const d = {
    findDebounced(m) {
      return f(m);
    }
  };
  function v(m) {
    const y = a(m);
    if (y && y.debounce)
      return y.debounce !== u.debounceTime && (d.findDebounced = he(f, y.debounce), u.debounceTime = y.debounce), d.findDebounced(y);
    if (y)
      return f(y);
  }
  const I = p(() => {
    const m = a();
    return typeof i.value == "function" ? l(i.value, m) : i.value;
  });
  return Y(
    () => [a(), I.value],
    ([m, y]) => {
      y && v();
    },
    { immediate: s }
  ), { ...c, ...me(u), find: v };
}
function fr({
  model: n,
  id: e,
  params: t = p(() => ({})),
  queryWhen: r = p(() => !0),
  local: i = !1,
  immediate: o = !0
}) {
  if (!n)
    throw new Error("No model provided for useGetWatched(). Did you define and register it with FeathersPinia?");
  function s() {
    return b(e);
  }
  function a() {
    return b(t);
  }
  const u = ve({
    isPending: !1,
    hasBeenRequested: !1,
    hasLoaded: !1,
    error: null,
    isLocal: i,
    request: null
  }), c = {
    item: p(() => {
      const f = s();
      return f === null ? null : n.getFromStore(f, a()) || null;
    }),
    servicePath: p(() => n.servicePath),
    isSsr: p(() => n.store.isSsr)
  };
  async function l(f, d) {
    const v = b(f), I = b(d);
    if (v != null && r.value && !u.isLocal) {
      u.isPending = !0, u.error = null, u.hasBeenRequested = !0;
      const m = I != null ? n.get(v, I) : n.get(v);
      u.request = m;
      try {
        const y = await m;
        return u.isPending = !1, u.hasLoaded = !0, y;
      } catch (y) {
        return u.isPending = !1, u.error = y, y;
      }
    } else
      return Promise.resolve(void 0);
  }
  return Y(
    () => [s(), a(), r.value],
    ([f, d]) => {
      l(f, d);
    },
    { immediate: o }
  ), Y(
    () => c.item.value,
    (f) => {
      f && (u.error = null);
    }
  ), {
    ...me(u),
    ...c,
    get: l
  };
}
function dr(n) {
  return Object.assign({
    find(t) {
      const r = H(t), { query: i = {} } = r;
      (r.paginate === !0 || D(i, "$limit") || D(i, "$skip")) && (r.paginate = { default: !0 }), this.setPendingById("Model", "find", !0);
      const s = V(r, {}), a = this.pagination[s.qid], u = a == null ? void 0 : a[s.queryId], c = u == null ? void 0 : u[s.pageId];
      let l;
      if (c != null && c.ssr) {
        const f = {
          data: c.ids.map((d) => this.getFromStore(d)),
          limit: c.pageParams.$limit,
          skip: c.pageParams.$skip,
          total: u.total,
          fromSsr: !0
        };
        l = Promise.resolve(f), r.preserveSsr || this.unflagSsr(r);
      }
      return (l || this.service.find(r)).then((f) => this.handleFindResponse({ params: r, response: f })).catch((f) => this.handleFindError({ params: r, error: f })).finally(() => {
        this.setPendingById("Model", "find", !1);
      });
    },
    async handleFindResponse({ params: t, response: r }) {
      const { idField: i } = this, { qid: o = "default", query: s, preserveSsr: a = !1 } = t;
      Array.isArray(r) && (r = { data: r }), this.addOrUpdate(r.data), r.data && this.updatePaginationForQuery({ qid: o, response: r, query: s, preserveSsr: a });
      const c = r.data.map((l) => this.itemsById[$(l, i)]);
      return c[0] !== void 0 && (r.data ? r.data = c : r = c), r = await this.afterFind(r), r;
    },
    async afterFind(t) {
      return t;
    },
    handleFindError({ error: t }) {
      return Promise.reject(t);
    },
    count(t) {
      const r = H(t), { query: i = {} } = r;
      return i.$limit = 0, Object.assign(r, { query: i }), this.setPendingById("Model", "count", !0), this.service.find(r).finally(() => {
        this.setPendingById("Model", "count", !1);
      });
    },
    get(t, r) {
      const i = H(r), o = i.skipRequestIfExists || this.skipRequestIfExists;
      delete i.skipRequestIfExists;
      const s = this.getFromStore(t, i);
      return s && o ? Promise.resolve(s) : (this.setPendingById("Model", "get", !0), this.service.get(t, i).then((a) => (this.addOrUpdate(a), this.setPendingById("Model", "get", !1), this.itemsById[t])).catch((a) => (this.setPendingById("Model", "get", !1), Promise.reject(a))));
    },
    create(t, r) {
      const i = H(r), { idField: o, tempIdField: s } = this;
      return Array.isArray(t) || this.setPendingById($(t, o) || t[s], "create", !0), this.service.create(be(t, this.Model.tempIdField), i).then((a) => this.addOrUpdate(Ht(t, a, this.Model.tempIdField))).catch((a) => Promise.reject(a)).finally(() => {
        Array.isArray(t) || this.setPendingById($(t, o) || t[s], "create", !1);
      });
    },
    update(t, r, i) {
      const o = H(i);
      return this.setPendingById(t, "update", !0), this.service.update(t, be(r, this.Model.tempIdField), o).then((s) => this.addOrUpdate(s)).catch((s) => Promise.reject(s)).finally(() => {
        this.setPendingById(t, "update", !1);
      });
    },
    patch(t, r, i) {
      const o = H(i);
      return o && o.data && (r = o.data), this.setPendingById(t, "patch", !0), this.service.patch(t, be(r, this.Model.tempIdField), o).then((s) => this.addOrUpdate(s)).catch((s) => Promise.reject(s)).finally(() => {
        this.setPendingById(t, "patch", !1);
      });
    },
    remove(t, r) {
      const i = H(r);
      return this.setPendingById(t, "remove", !0), this.service.remove(t, i).then((o) => (this.setPendingById(t, "remove", !1), this.removeFromStore(o), o)).catch((o) => (this.setPendingById(t, "remove", !1), Promise.reject(o)));
    },
    removeFromStore(t) {
      const { items: r } = re(t), { idField: i, tempIdField: o } = this, s = r.map((a) => $(a, i) != null ? $(a, i) : K(a, o)).filter((a) => a != null);
      return F(this, "itemsById", k.omit(this.itemsById, ...s)), F(this, "clonesById", k.omit(this.clonesById, ...s)), F(this, "pendingById", k.omit(this.pendingById, ...s)), F(this, "tempsById", k.omit(this.tempsById, ...s)), t;
    },
    addToStore(t) {
      return this.addOrUpdate(t);
    },
    addOrUpdate(t) {
      const { idField: r, tempIdField: i } = this, { items: o, isArray: s } = re(t), a = o.map((u) => $(u, r) != null && K(u, i) != null ? this.moveTempToItems(u) : pr(u, this, n));
      return s ? a : a[0];
    },
    moveTempToItems(t) {
      const { idField: r, tempIdField: i } = this, o = $(t, r), s = K(t, i), a = this.tempsById[s];
      return a && (F(this.itemsById, o, Object.assign(a, t)), delete this.tempsById[s], delete this.itemsById[o][i]), delete t[i], this.itemsById[o];
    },
    clearAll() {
      F(this, "itemsById", {}), F(this, "tempsById", {}), F(this, "clonesById", {});
    },
    clone(t, r = {}, i = {}) {
      const s = K(t, this.Model.tempIdField) != null ? "tempsById" : "itemsById", a = ae(t, this.Model.tempIdField, this.Model.idField), u = this[s][a], c = this.clonesById[a];
      if (c)
        return i.useExisting ? c : this.reset(t, r);
      {
        const l = Q(u);
        return De(l), Ge(u, l, l.Model.associations), Object.assign(l, r), F(this.clonesById, a, l), this.clonesById[a];
      }
    },
    commit(t, r = {}) {
      const i = ae(t, this.Model.tempIdField, this.Model.idField);
      if (i != null) {
        const s = K(t, this.Model.tempIdField) != null ? "tempsById" : "itemsById", a = this.clonesById[i], u = Q(a);
        return Object.assign(u, r), Ge(a, u, a.Model.associations), F(this[s], i, u), this[s][i];
      }
    },
    reset(t, r = {}) {
      const o = K(t, this.Model.tempIdField) != null ? "tempsById" : "itemsById", s = ae(t, this.Model.tempIdField, this.Model.idField), a = this[o][s], u = this.clonesById[s];
      if (!u)
        return this.clone(t, r);
      const c = Object.assign(u, a, r);
      return Object.keys(c).forEach((l) => {
        D(a, l) || delete c[l];
      }), De(c), c;
    },
    updatePaginationForQuery({ qid: t, response: r, query: i = {}, preserveSsr: o = !1 }) {
      var A, T;
      const { data: s, total: a } = r, { idField: u } = this, c = s.map((U) => $(U, u)), l = new Date().getTime(), { queryId: f, queryParams: d, pageId: v, pageParams: I } = V({ qid: t, query: i }, r);
      this.pagination[t] || F(this.pagination, t, {}), !D(i, "$limit") && D(r, "limit") && F(this.pagination, "defaultLimit", r.limit), !D(i, "$skip") && D(r, "skip") && F(this.pagination, "defaultSkip", r.skip);
      const m = {
        query: i,
        queryId: f,
        queryParams: d,
        pageId: v,
        pageParams: I,
        queriedAt: l,
        total: a
      }, y = (T = (A = this.pagination[t]) == null ? void 0 : A[f]) == null ? void 0 : T[v], g = this.pagination[t] || {};
      Object.assign(g, { mostRecent: m }), F(g, f, g[f] || {});
      const O = {
        total: a,
        queryParams: d
      };
      F(g, f, Object.assign({}, g[f], O));
      const L = o ? y == null ? void 0 : y.ssr : b(n.ssr), B = {
        [v]: { pageParams: I, ids: c, queriedAt: l, ssr: !!L }
      };
      Object.assign(g[f], B);
      const M = Object.assign({}, this.pagination[t], g);
      F(this.pagination, t, M);
    },
    setPendingById(t, r, i) {
      t != null && (F(this.pendingById, t, this.pendingById[t] || { [r]: i }), F(this.pendingById[t], r, i));
    },
    hydrateAll() {
      this.addToStore(this.items);
    },
    toggleEventLock(t, r) {
      hr(t, r, !0, this);
    },
    unflagSsr(t) {
      var u, c;
      const r = V(t, {}), { qid: i, queryId: o, pageId: s } = r, a = (c = (u = this.pagination[i]) == null ? void 0 : u[o]) == null ? void 0 : c[s];
      a.ssr = !1;
    },
    useFind(t) {
      return (t.value || t).store = this, bt(t);
    },
    useGet(t, r = {}) {
      return (r.value || r).store = this, Ye(t, r);
    },
    useGetOnce(t, r = {}) {
      Object.assign(r.value || r, { store: this, immediate: !1, onServer: !0 });
      const i = Ye(t, r);
      return i.queryWhen(() => !i.data.value), i.get(), i;
    },
    useFindWatched(t) {
      return lr({ model: this.Model, ...t });
    },
    useGetWatched(t) {
      return fr({ model: this.Model, ...t });
    }
  }, n.actions);
}
function hr(n, e, t, r) {
  const { items: i } = re(n);
  i.forEach((o) => {
    r.eventLocksById[e][o] ? delete r.eventLocksById[e][o] : F(r.eventLocksById[e], o, !0);
  });
}
function pr(n, e, t) {
  const { idField: r, tempIdField: i, servicePath: o, isSsr: s } = e, a = $(n, r) != null ? "itemsById" : "tempsById";
  a === "tempsById" && !n[i] && Yt(n, i);
  const u = ae(n, i, r), c = e[a][u];
  if (c ? Object.assign(c, n) : e[a][u] = new t.Model(n), s || !(n instanceof t.Model)) {
    const f = { [o]: t.Model };
    e[a][u] = new f[o](c ? Object.assign(c, n) : n);
  }
  return e[a][u];
}
function vr(n) {
  const e = mr(n), {
    servicePath: t,
    idField: r,
    tempIdField: i,
    handleEvents: o,
    debounceEventsTime: s,
    debounceEventsGuarantee: a,
    clientAlias: u,
    Model: c
  } = e;
  let l = !1;
  Object.keys(e.clients || {}).forEach((y) => {
    dt(y, e.clients[y]);
  });
  const f = e.id || `service.${e.servicePath}`, d = dn({
    clientAlias: u,
    servicePath: t,
    idField: r,
    tempIdField: i,
    whitelist: e.whitelist,
    paramsForServer: e.paramsForServer,
    skipRequestIfExists: e.skipRequestIfExists,
    state: e.state
  }), v = ur({
    clients: ee,
    Model: c,
    ssr: e.ssr,
    getters: e.getters
  }), I = dr({
    clients: ee,
    getters: v,
    actions: e.actions,
    Model: c,
    ssr: e.ssr
  });
  function m(y) {
    const O = Xe({
      id: f,
      state: d,
      getters: v,
      actions: I
    })(y);
    if (O.isSsr, !l) {
      l = !0, Object.assign(e.Model, {
        store: O,
        pinia: y,
        servicePath: e.servicePath,
        idField: r,
        tempIdField: i,
        clients: ee,
        ...Object.keys(e.actions).reduce((A, T) => {
          const U = e.actions[T];
          return A[T] = U.bind(O), A;
        }, {})
      });
      const L = ee[u];
      if (!L)
        throw new Error(
          `There is no registered FeathersClient named '${u}'. You need to provide one in the 'defineStore' options.`
        );
      const B = L.service(t), M = { idField: r, debounceEventsTime: s, debounceEventsGuarantee: a, handleEvents: o };
      tn(e.Model, O), fn({
        service: B,
        Model: c,
        store: O,
        options: M
      });
    }
    return O;
  }
  return m;
}
function mr(n) {
  var o, s, a, u, c;
  const t = Object.assign({
    clientAlias: "api",
    servicePath: "",
    idField: "id",
    tempIdField: "__tempId",
    paramsForServer: [],
    whitelist: [],
    skipRequestIfExists: !1
  }, {
    id: `service.${n.servicePath}`,
    ssr: !1,
    clients: {},
    enableEvents: !0,
    handleEvents: {},
    debounceEventsTime: 20,
    debounceEventsGuarantee: !1,
    state: () => ({}),
    getters: {},
    actions: {}
  });
  let r;
  n.Model ? r = n.Model : r = (o = class extends N {
  }, h(o, "dynamicBaseModel", !0), h(o, "modelName", n.servicePath), o), r.modelName || (r.modelName = r.name);
  const i = Object.assign(t, { Model: r }, n);
  return (s = i.handleEvents).created || (s.created = () => i.enableEvents), (a = i.handleEvents).patched || (a.patched = () => i.enableEvents), (u = i.handleEvents).updated || (u.updated = () => i.enableEvents), (c = i.handleEvents).removed || (c.removed = () => i.enableEvents), i;
}
function _r(n) {
  const { clients: e } = n;
  Object.keys(e).forEach((r) => {
    dt(r, e[r]);
  });
  function t(...r) {
    const i = r.length === 2 ? r[0] : r[0].id, o = r.length === 2 ? r[1] : r[0];
    return o.id = i || `service.${o.servicePath}`, vr(Object.assign({}, n, o));
  }
  return {
    defineStore: t,
    BaseModel: N
  };
}
function Br(...n) {
  const e = n.length === 2 ? n[0] : n[0].id || "auth", t = n.length === 2 ? n[1] : n[0], { feathersClient: r, state: i = () => ({}), getters: o = {}, actions: s = {} } = t, a = {
    isLoading: !0,
    isAuthenticated: !1,
    accessToken: null,
    payload: null,
    error: null
  }, u = {
    feathersClient() {
      return r;
    }
  }, c = {
    async authenticate(f) {
      try {
        const d = await r.authenticate(f);
        return Object.assign(this, { ...d, isAuthenticated: !0 }), this.handleResponse(d) || d;
      } catch (d) {
        return this.error = d, this.handleError(d);
      }
    },
    handleResponse(f) {
      return f;
    },
    handleError(f) {
      return Promise.reject(f);
    },
    setLoaded() {
      this.isLoading = !1;
    }
  };
  return Xe({
    id: e,
    state: () => Object.assign(a, i()),
    getters: Object.assign(u, o),
    actions: Object.assign(c, s)
  });
}
function fe(n, e, t) {
  if (t) {
    const r = t(n);
    return r.temps !== !1 && (r.temps = !0), Object.assign({}, r, { store: e });
  }
}
function yr(n) {
  return n;
}
function $t(n, e, t, r, i) {
  const o = { name: t, Model: r, type: "get" }, s = e || yr;
  n.Model.associations[t] || (n.Model.associations[t] = o);
  const a = `${i}${t}`;
  return { _handleSetInstance: s, propUtilName: a };
}
function Ar(n, e, { Model: t, makeParams: r, handleSetInstance: i, propUtilsPrefix: o = "_" }) {
  const s = n[e], { _handleSetInstance: a, propUtilName: u } = $t(
    n,
    i,
    e,
    t,
    o
  );
  let c;
  function l(f) {
    if (!r)
      return null;
    const d = fe(f, t.store, r);
    c = new Pt(d), c.useFind = (v) => {
      const I = v.value || v;
      return I.store = t.store, bt(v);
    };
  }
  if (Object.defineProperty(n, e, {
    enumerable: !1,
    get() {
      return c || l(this), c.data.value;
    },
    set(f) {
      f.map((d) => new t(d).addToStore()).map((d) => a.call(this, d));
    }
  }), Object.defineProperty(n, u, {
    enumerable: !1,
    get() {
      return c || l(this), c;
    }
  }), s) {
    const f = n;
    f[e] = s;
  }
}
function xr(n, e, { Model: t, getId: r, makeParams: i, handleSetInstance: o, propUtilsPrefix: s = "_" }) {
  const a = n[e], { _handleSetInstance: u, propUtilName: c } = $t(
    n,
    o,
    e,
    t,
    s
  ), l = {
    get(f, d) {
      const v = r(n) || f, I = fe(n, t.store, i) || d;
      return t.get(v, I);
    },
    getFromStore(f, d) {
      const v = n.getId() || f, I = fe(n, t.store, i) || d;
      return t.getFromStore(v, I);
    }
  };
  if (Object.defineProperty(n, e, {
    enumerable: !1,
    get() {
      const f = r(this);
      let d;
      return i && (d = fe(this, t.store, i)), t.getFromStore(f, d);
    },
    set(f) {
      const d = new t(f).addToStore();
      return u.call(this, d);
    }
  }), Object.defineProperty(n, c, {
    configurable: !0,
    enumerable: !1,
    value: l
  }), a) {
    const f = n;
    f[e] = a;
  }
}
class Mr extends qt {
  async request(e, t) {
    const r = Object.assign({}, e, t.connection);
    r.headers = Object.assign({ Accept: "application/json" }, this.options.headers, r.headers), e.body && (r.body = e.body);
    try {
      const i = await this.connection.raw(e.url, r), { _data: o, status: s } = i;
      return s === 204 ? null : o;
    } catch (i) {
      throw console.error("feathers-ofetch request error", i), i;
    }
  }
}
function Cr(n, e) {
  const t = Z(n, "$limit"), r = Z(n, "$skip"), i = p(() => e.value.response.total), { pageCount: o, currentPage: s, canPrev: a, canNext: u, toStart: c, toEnd: l, toPage: f, next: d, prev: v } = St(
    t,
    r,
    i
  ), I = p(() => {
    const m = b(e);
    return m && m.response ? m.response.total : 0;
  });
  return Y(
    () => o.value,
    () => {
      const m = e.value;
      m && m.response && s.value > o.value && (s.value = o.value);
    }
  ), {
    itemsCount: I,
    pageCount: o,
    currentPage: s,
    canPrev: a,
    canNext: u,
    toStart: c,
    toEnd: l,
    toPage: f,
    next: d,
    prev: v
  };
}
function gr(n, e, t = {}) {
  const { useExisting: r = !1, deep: i = !1 } = t, o = i ? p(s) : j(null);
  function s() {
    const u = n[e];
    if (!(u instanceof N))
      return null;
    const c = u, l = c.getAnyId();
    return c.Model.getFromStore(l) || c.addToStore(), c ? c == null ? void 0 : c.clone(void 0, { useExisting: r }) : null;
  }
  let a = null;
  return i || jt(() => {
    me(ve(n));
    const u = n[e];
    if (!u)
      a = null, o.value = null;
    else if (u.getAnyId) {
      const c = u.getAnyId();
      c !== a && (a = c, o.value = s());
    }
  }), o;
}
function Tr(n, e = {}) {
  const t = ve({});
  return Object.keys(n).forEach((r) => {
    t[r] = gr(n, r, e);
  }), me(t);
}
function _e(n) {
  this.message = n;
}
_e.prototype = new Error(), _e.prototype.name = "InvalidCharacterError";
var He = typeof window < "u" && window.atob && window.atob.bind(window) || function(n) {
  var e = String(n).replace(/=+$/, "");
  if (e.length % 4 == 1)
    throw new _e("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var t, r, i = 0, o = 0, s = ""; r = e.charAt(o++); ~r && (t = i % 4 ? 64 * t + r : r, i++ % 4) ? s += String.fromCharCode(255 & t >> (-2 * i & 6)) : 0)
    r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(r);
  return s;
};
function Ir(n) {
  var e = n.replace(/-/g, "+").replace(/_/g, "/");
  switch (e.length % 4) {
    case 0:
      break;
    case 2:
      e += "==";
      break;
    case 3:
      e += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(t) {
      return decodeURIComponent(He(t).replace(/(.)/g, function(r, i) {
        var o = i.charCodeAt(0).toString(16).toUpperCase();
        return o.length < 2 && (o = "0" + o), "%" + o;
      }));
    }(e);
  } catch {
    return He(e);
  }
}
function pe(n) {
  this.message = n;
}
function Or(n, e) {
  if (typeof n != "string")
    throw new pe("Invalid token specified");
  var t = (e = e || {}).header === !0 ? 0 : 1;
  try {
    return JSON.parse(Ir(n.split(".")[t]));
  } catch (r) {
    throw new pe("Invalid token specified: " + r.message);
  }
}
pe.prototype = new Error(), pe.prototype.name = "InvalidTokenError";
const Nr = (n) => {
  const { api: e, userStore: t, skipTokenCheck: r } = n, i = n.entityKey || "user", o = z(), s = async () => {
  }, a = async (S) => {
    throw S;
  }, u = n.onSuccess || s, c = n.onError || a, l = n.onInitSuccess || s, f = n.onInitError || s, d = n.onLogoutSuccess || s, v = n.onLogoutError || a, I = z(null), m = we(() => (t == null ? void 0 : t.getFromStore(I)) || null), y = z(null), g = () => y.value = null, O = ze(), L = we(() => !!O.count.value), B = z(!1), M = async (S) => (O.add(), g(), o.value = e.authenticate(S).then(A).then(async (q) => await u(q) || q).catch((q) => (y.value = q, c(q))), o.value), A = (S) => {
    const q = S[i];
    if (t && q) {
      const X = t.addToStore(q);
      I.value = X.getId();
    }
    return B.value = !0, S;
  }, T = z(!1), U = () => {
    O.sub(), T.value = !0;
  }, W = async () => (O.add(), o.value = e.authentication.getAccessToken().then((S) => {
    if (S && !r && P(S))
      throw e.authentication.removeAccessToken(), new _t("accessToken expired");
  }).then(() => e.reAuthenticate()).then(A).then(async (S) => await l(S) || S).catch(f).finally(() => U()), o.value), P = (S) => {
    try {
      const q = Or(S);
      return new Date().getTime() > q.exp * 1e3;
    } catch {
      return !1;
    }
  }, x = ze(), E = we(() => !!x.count.value), C = async () => (x.add(), e.logout().then((S) => (I.value = null, B.value = !1, S)).then(d).catch((S) => (S.value = S, v(S))).finally(() => x.sub())), G = z(null);
  return {
    user: m,
    error: y,
    isPending: L,
    isLogoutPending: E,
    isInitDone: T,
    isAuthenticated: B,
    loginRedirect: G,
    getPromise: () => o.value,
    isTokenExpired: P,
    authenticate: M,
    reAuthenticate: W,
    logout: C,
    clearError: g
  };
}, ze = () => {
  const n = z(0);
  return {
    count: n,
    add: () => {
      n.value = n.value + 1;
    },
    sub: () => {
      n.value = n.value === 0 ? 0 : n.value - 1;
    }
  };
};
function wr(n, e, t) {
  const r = JSON.stringify(e);
  t.setItem(n, r);
}
function Sr(n, e) {
  const t = e.getItem(n.$id);
  if (t) {
    const r = JSON.parse(t) || {};
    Object.assign(n, r);
  }
}
function Rr(n, e, t = window.localStorage) {
  Sr(n, t);
  const r = he(wr, 500), i = p(() => k.pick(n, ...e));
  Y(i, (o) => r(n.$id, o, t), { deep: !0 });
}
function Ur(n = window.localStorage) {
  Object.keys(n).map((e) => {
    e.startsWith("service.") && n.removeItem(e);
  });
}
export {
  N as BaseModel,
  Pt as Find,
  cr as Get,
  Mr as OFetch,
  Ar as associateFind,
  xr as associateGet,
  Ur as clearStorage,
  ee as clients,
  Br as defineAuthStore,
  vr as defineStore,
  te as models,
  dt as registerClient,
  _r as setupFeathersPinia,
  Rr as syncWithStorage,
  Nr as useAuth,
  gr as useClone,
  Tr as useClones,
  bt as useFind,
  lr as useFindWatched,
  Ye as useGet,
  fr as useGetWatched,
  Cr as usePagination
};
//# sourceMappingURL=feathers-pinia.mjs.map
